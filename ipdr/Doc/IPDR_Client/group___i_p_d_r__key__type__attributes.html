<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Key and type (template) attributes</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Key and type (template) attributes<br>
<small>
[<a class="el" href="group___i_p_d_r__templates.html">Templates and keys</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___template.html">IPDR_Template</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga20">IPDR_KEY_DISABLED</a>&nbsp;&nbsp;&nbsp;0x00000001UL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga21">IPDR_TYPE_VAR_LENGTH</a>&nbsp;&nbsp;&nbsp;0x4000U</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga22">IPDR_ACCESS_BY_FUNCTION</a>&nbsp;&nbsp;&nbsp;0x0001U</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga23">IPDR_ACCESS_BY_OFFSET</a>&nbsp;&nbsp;&nbsp;0x0002U</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga0">IPDR_KeyAccessor</a> )(const void *Data, void *ExtraData, const void **Value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga1">IPDR_Offset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga2">XDR_INT</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga33">IPDR_SessionStopReason</a> { , <br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a123">IPDR_STOP_REASON_SWITCHCOLLECTOR</a> =  1, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a124">IPDR_STOP_REASON_EXIT</a> =  2, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a125">IPDR_STOP_REASON_CONGESTION</a> =  3, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a126">IPDR_STOP_REASON_RENEGOTIATION</a> =  4, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a127">IPDR_STOP_REASON_STARTNEGOTIATION</a> =  5, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a128">IPDR_STOP_REASON_ENDOFDOCUMENT</a> =  6, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a129">IPDR_STOP_REASON_TEMPLATEUPDATED</a> =  7, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga33a130">IPDR_STOP_REASON_MINVENDOR</a> =  256
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html#ga34">XDR_KeyType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a131">XDR_TYPE_INT</a> =  0x0021U, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a132">XDR_TYPE_UINT</a> =  0x0022U, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a133">XDR_TYPE_LONG</a> =  0x0023U, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a134">XDR_TYPE_ULONG</a> =  0x0024U, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a135">XDR_TYPE_FLOAT</a> =  0x0025U, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a136">XDR_TYPE_DOUBLE</a> =  0x0026U
, <a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a138">XDR_TYPE_HEXBINARY</a> =  0x0027U | IPDR_TYPE_VAR_LENGTH, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a139">XDR_TYPE_STRING</a> =  0x0028U | IPDR_TYPE_VAR_LENGTH, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a140">XDR_TYPE_BOOLEAN</a> =  0x0029U, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a141">XDR_TYPE_BYTE</a> =  0x002aU, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a142">XDR_TYPE_UBYTE</a> =  0x002bU, 
<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a143">XDR_TYPE_SHORT</a> =  0x002cU, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a144">XDR_TYPE_USHORT</a> =  0x002dU
<br>
 }</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Each key is identified in the context of its enclosing template. For every key there is an optional accessor function that takes as its argument a pointer to the actual (raw) data, and returns a pointer to the value of the key.<p>
One of a key's attributes is a flag, which enables / disables the export of the key <hr><h2>Define Documentation</h2>
<a class="anchor" name="ga22" doxytag="IPDR.h::IPDR_ACCESS_BY_FUNCTION"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define IPDR_ACCESS_BY_FUNCTION&nbsp;&nbsp;&nbsp;0x0001U          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a value from a record by a function callback (possible value for <a class="el" href="struct_i_p_d_r___key.html#o6">IPDR_Key::AccessType</a>).     </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="IPDR.h::IPDR_ACCESS_BY_OFFSET"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define IPDR_ACCESS_BY_OFFSET&nbsp;&nbsp;&nbsp;0x0002U          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access a value from a record by an offset (possible value for <a class="el" href="struct_i_p_d_r___key.html#o6">IPDR_Key::AccessType</a>).     </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="IPDR.h::IPDR_KEY_DISABLED"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define IPDR_KEY_DISABLED&nbsp;&nbsp;&nbsp;0x00000001UL          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mask for disabling a key in a template (for IPDR_Key::KeyAttributes).     </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="IPDR.h::IPDR_TYPE_VAR_LENGTH"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define IPDR_TYPE_VAR_LENGTH&nbsp;&nbsp;&nbsp;0x4000U          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convention with IPDR_KeyType values for varying length fields: this value is "or"ed with the key type (e.g., <a class="el" href="group___i_p_d_r__key__type__attributes.html#gga34a139">XDR_TYPE_STRING</a>).     </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="IPDR.h::IPDR_KeyAccessor"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga0">IPDR_KeyAccessor</a>)(const void *Data, void *ExtraData, const void **Value)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access data using a functional callback. For each field being output by IPDR, the data field needs to be accessed. For the <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga23">IPDR_ACCESS_BY_OFFSET</a> case, this can be done by computing the pointer as <code>Data+(IPDR_Offset)key.KeyAccessor</code>. For the <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga22">IPDR_ACCESS_BY_FUNCTION</a> case, the pointer is computed by this key access callback. The callback is called only if the key is enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>The data record being output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ExtraData</em>&nbsp;</td><td>The extra data recorded with <a class="el" href="struct_i_p_d_r___key.html#o7">IPDR_Key::ExtraData</a> for this field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>(updated) pointer to the data field to be transmitted. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="IPDR.h::IPDR_Offset"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef unsigned int <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga1">IPDR_Offset</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type to use for accessing a field offset.     </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="IPDR.h::XDR_INT"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga2">XDR_INT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Key types definitions (for <a class="el" href="struct_i_p_d_r___key.html#o1">IPDR_Key::KeyTypeID</a>). These are in IPDR/XDR Encoding format, v. 3.5.1, section 4.3.1.2     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga33" doxytag="IPDR.h::IPDR_SessionStopReason"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga33">IPDR_SessionStopReason</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Session stop reason codes <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga33a123" doxytag="IPDR_STOP_REASON_SWITCHCOLLECTOR"></a>IPDR_STOP_REASON_SWITCHCOLLECTOR</em>&nbsp;</td><td>
end of data for session </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a124" doxytag="IPDR_STOP_REASON_EXIT"></a>IPDR_STOP_REASON_EXIT</em>&nbsp;</td><td>
1 = handing off to higher priority Collector </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a125" doxytag="IPDR_STOP_REASON_CONGESTION"></a>IPDR_STOP_REASON_CONGESTION</em>&nbsp;</td><td>
2 = Exporter terminating </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a126" doxytag="IPDR_STOP_REASON_RENEGOTIATION"></a>IPDR_STOP_REASON_RENEGOTIATION</em>&nbsp;</td><td>
3 = congestion detected </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a127" doxytag="IPDR_STOP_REASON_STARTNEGOTIATION"></a>IPDR_STOP_REASON_STARTNEGOTIATION</em>&nbsp;</td><td>
4 = renegotiation is required </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a128" doxytag="IPDR_STOP_REASON_ENDOFDOCUMENT"></a>IPDR_STOP_REASON_ENDOFDOCUMENT</em>&nbsp;</td><td>
5 = start negotiation acknowledge </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a129" doxytag="IPDR_STOP_REASON_TEMPLATEUPDATED"></a>IPDR_STOP_REASON_TEMPLATEUPDATED</em>&nbsp;</td><td>
6 = end of IPDRDoc </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga33a130" doxytag="IPDR_STOP_REASON_MINVENDOR"></a>IPDR_STOP_REASON_MINVENDOR</em>&nbsp;</td><td>
7 = Template data was updated </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga34" doxytag="IPDR.h::XDR_KeyType"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga34">XDR_KeyType</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Key types identifiers (for <a class="el" href="struct_i_p_d_r___key.html#o1">IPDR_Key::KeyTypeID</a>). These are in IPDR/XDR Encoding format, v. 3.5.1, section 4.3.1.2 <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga34a131" doxytag="XDR_TYPE_INT"></a>XDR_TYPE_INT</em>&nbsp;</td><td>
an integer in the range [-2147483648,2147483647] </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a132" doxytag="XDR_TYPE_UINT"></a>XDR_TYPE_UINT</em>&nbsp;</td><td>
a nonnegative integer in the range [0,4294967295] </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a133" doxytag="XDR_TYPE_LONG"></a>XDR_TYPE_LONG</em>&nbsp;</td><td>
obvious extensions of integer and unsigned integer defined above. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a134" doxytag="XDR_TYPE_ULONG"></a>XDR_TYPE_ULONG</em>&nbsp;</td><td>
obvious extensions of integer and unsigned integer defined above. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a135" doxytag="XDR_TYPE_FLOAT"></a>XDR_TYPE_FLOAT</em>&nbsp;</td><td>
4 bytes single-precision floating-point number </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a136" doxytag="XDR_TYPE_DOUBLE"></a>XDR_TYPE_DOUBLE</em>&nbsp;</td><td>
8 bytes double-precision floating-point number </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a138" doxytag="XDR_TYPE_HEXBINARY"></a>XDR_TYPE_HEXBINARY</em>&nbsp;</td><td>
4 byte length indication + the number of bytes of hex data </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a139" doxytag="XDR_TYPE_STRING"></a>XDR_TYPE_STRING</em>&nbsp;</td><td>
4 byte length followed by string </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a140" doxytag="XDR_TYPE_BOOLEAN"></a>XDR_TYPE_BOOLEAN</em>&nbsp;</td><td>
1 byte value which contains 0 for FALSE and 1 for TRUE </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a141" doxytag="XDR_TYPE_BYTE"></a>XDR_TYPE_BYTE</em>&nbsp;</td><td>
an integer in the range[-128,127] </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a142" doxytag="XDR_TYPE_UBYTE"></a>XDR_TYPE_UBYTE</em>&nbsp;</td><td>
a non-negative integer in the range[0,255] </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a143" doxytag="XDR_TYPE_SHORT"></a>XDR_TYPE_SHORT</em>&nbsp;</td><td>
an integer in the range [-32783,32782] </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga34a144" doxytag="XDR_TYPE_USHORT"></a>XDR_TYPE_USHORT</em>&nbsp;</td><td>
a non-negative integer in the range [0,65565] </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon May 30 15:54:42 2005 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
