<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Event notification</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Event notification</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___event_connected_data.html">IPDR_EventConnectedData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___event_disconnected_data.html">IPDR_EventDisconnectedData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___record_lost_data.html">IPDR_RecordLostData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___server_changed_data.html">IPDR_ServerChangedData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___error_data.html">IPDR_ErrorData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___event_flow_start_data.html">IPDR_EventFlowStartData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___event_final_template_data_ack.html">IPDR_EventFinalTemplateDataAck</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___event_data.html">IPDR_EventData</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga0">IPDR_DSN_TYPE</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga1">IPDR_EventCallbackDetailed</a> )(const <a class="el" href="struct_i_p_d_r___event_data.html">IPDR_EventData</a> *Event, const char *Msg, void *Arg)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga4">IPDR_Event_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__event__notification.html#gga4a152">IPDR_EVENT_SERVER_CONNECTED</a> =  0x0001, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga4a153">IPDR_EVENT_SERVER_DISCONNECTED</a> =  0x0002, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga4a154">IPDR_EVENT_RECORD_LOST</a> =  0x0003, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga4a155">IPDR_EVENT_ACTIVE_SERVER_CHANGED</a> =  0x0004, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__event__notification.html#gga4a156">IPDR_EVENT_QUEUE_EMPTY</a> =  0x0005, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga4a157">IPDR_EVENT_ALL_SERVERS_DISCONNECTED</a> =  0x0006, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga4a158">IPDR_EVENT_ERROR</a> =  0x0007, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga4a159">IPDR_EVENT_FLOWSTART</a> =  0x0008, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__event__notification.html#gga4a160">IPDR_EVENT_FINALTEMPLATEACK</a> =  0x0009
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga5">IPDR_EventDisconnected_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__event__notification.html#gga5a161">IPDR_EVENT_DISCONNECTED_INITIAL</a> =  0, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga5a162">IPDR_EVENT_DISCONNECTED_TIMEOUT</a> =  1, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga5a163">IPDR_EVENT_DISCONNECTED_TCP</a> =  2, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga5a164">IPDR_EVENT_DISCONNECTED_STOP</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="group___i_p_d_r__event__notification.html#gga5a165">IPDR_EVENT_DISCONNECTED_TOO_SLOW</a> =  4
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga6">IPDR_EventError_t</a> { <a class="el" href="group___i_p_d_r__event__notification.html#gga6a166">IPDR_EVENT_ERROR_UNKNOWN_SERVER</a> =  1, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga6a167">IPDR_EVENT_ERROR_UNKNOWN_SESSION</a> =  2, 
<a class="el" href="group___i_p_d_r__event__notification.html#gga6a168">IPDR_EVENT_ERROR_UNEXPECTED_CONNECT</a> =  3
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *IPDR_API_LINKAGE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga2">IPDR_EventMsg</a> (const <a class="el" href="struct_i_p_d_r___event_data.html">IPDR_EventData</a> *Event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__event__notification.html#ga3">IPDR_SetExporterEventHandlerDetailed</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="group___i_p_d_r__event__notification.html#ga1">IPDR_EventCallbackDetailed</a> Callback, void *Arg)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The IPDR transmitter (client) may trigger events in specific conditions. The conditions include a connection or disconnection to / from a collector (server), a change in the currently active collector (server) or data loss. The host application may register a callback function which will be called once an event is triggered within the transmitter (client). This can be used for example to link the IPDR transmitter (client) to the management facilities of the network element <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="IPDR.h::IPDR_DSN_TYPE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef unsigned long long <a class="el" href="group___i_p_d_r__event__notification.html#ga0">IPDR_DSN_TYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type for data sequence numbers. Note that an older form of the protocol used signed numbers and reset the counter back to zero, reserving -1 for a kind of keep-alive. This has been changed to use a 64-bit unsigned number, with any keep-alive being done differently.     </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="IPDR.h::IPDR_EventCallbackDetailed"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__event__notification.html#ga1">IPDR_EventCallbackDetailed</a>)(const <a class="el" href="struct_i_p_d_r___event_data.html">IPDR_EventData</a> *Event, const char *Msg, void *Arg)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback for an event. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Event</em>&nbsp;</td><td>The event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Msg</em>&nbsp;</td><td>Message associated with the event. The content of the message is subject to change. If you wish to get any additional information about the event, use the Event parameter; the message is simply a convenience for outputting som text about the error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>Context value given when callback was registered by calling <a class="el" href="group___i_p_d_r__event__notification.html#ga3">IPDR_SetExporterEventHandlerDetailed()</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga4" doxytag="IPDR.h::IPDR_Event_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group___i_p_d_r__event__notification.html#ga4">IPDR_Event_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Event types <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga4a152" doxytag="IPDR_EVENT_SERVER_CONNECTED"></a>IPDR_EVENT_SERVER_CONNECTED</em>&nbsp;</td><td>
Connection to a collector occurred; this may be followed by a <a class="el" href="group___i_p_d_r__event__notification.html#gga4a155">IPDR_EVENT_ACTIVE_SERVER_CHANGED</a> event. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a153" doxytag="IPDR_EVENT_SERVER_DISCONNECTED"></a>IPDR_EVENT_SERVER_DISCONNECTED</em>&nbsp;</td><td>
Disconnection from a collector occurred - this can be either a real disconnection (TCP close) or a a timeout which may or may not cause an actual TCP-level disconnection. It is possible that this event can be triggered multiple times (usually with different reasons) for the same collector (server), without an intervening <a class="el" href="group___i_p_d_r__event__notification.html#gga4a152">IPDR_EVENT_SERVER_CONNECTED</a> event. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a154" doxytag="IPDR_EVENT_RECORD_LOST"></a>IPDR_EVENT_RECORD_LOST</em>&nbsp;</td><td>
A record was lost because of no room on the queued; if output is being done with <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a>, you will get both a <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a202">IPDR_ERR_QUEUE_FULL</a> error and a record lost event. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a155" doxytag="IPDR_EVENT_ACTIVE_SERVER_CHANGED"></a>IPDR_EVENT_ACTIVE_SERVER_CHANGED</em>&nbsp;</td><td>
The active collector (server) was changed to a higher priority one. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a156" doxytag="IPDR_EVENT_QUEUE_EMPTY"></a>IPDR_EVENT_QUEUE_EMPTY</em>&nbsp;</td><td>
The internal queue has become empty (used to detect when it it is safe to delete a transmitter (client) because all data have been sent and acknowledged). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a157" doxytag="IPDR_EVENT_ALL_SERVERS_DISCONNECTED"></a>IPDR_EVENT_ALL_SERVERS_DISCONNECTED</em>&nbsp;</td><td>
All the collectors (servers) have been disconnected, so any records that are sent are guaranteed to queue up (and possibly overflow the internal queue) until at least one collector (server) starts again (see <a class="el" href="group___i_p_d_r__event__notification.html#gga4a152">IPDR_EVENT_SERVER_CONNECTED</a>). This event contains no extra information because an earlier #IPDR_EVENT_SERVER_DISCONENCTED will have given the reason for the collector (server) disconnection(s). It is possible that this event can be triggered multiple times before a <a class="el" href="group___i_p_d_r__event__notification.html#gga4a152">IPDR_EVENT_SERVER_CONNECTED</a> is generated. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a158" doxytag="IPDR_EVENT_ERROR"></a>IPDR_EVENT_ERROR</em>&nbsp;</td><td>
An unrecoverable processing error has occurred. Details are given by the <a class="el" href="group___i_p_d_r__event__notification.html#ga6">IPDR_EventError_t</a> enumeration. In general, this exception is used only for <em>asynchronous</em> events, so you <em>must</em> check return codes in addition to handling error events. (Some events can be synchronous, depending on the implementation.) Not all error events result in an event callback; some simply put a message in the log. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a159" doxytag="IPDR_EVENT_FLOWSTART"></a>IPDR_EVENT_FLOWSTART</em>&nbsp;</td><td>
Some Collector sent Flow Start Message </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga4a160" doxytag="IPDR_EVENT_FINALTEMPLATEACK"></a>IPDR_EVENT_FINALTEMPLATEACK</em>&nbsp;</td><td>
Some Collector sent Final Template Data Ack Message </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="IPDR.h::IPDR_EventDisconnected_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group___i_p_d_r__event__notification.html#ga5">IPDR_EventDisconnected_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reason for a disconnection. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga5a161" doxytag="IPDR_EVENT_DISCONNECTED_INITIAL"></a>IPDR_EVENT_DISCONNECTED_INITIAL</em>&nbsp;</td><td>
Initial state. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga5a162" doxytag="IPDR_EVENT_DISCONNECTED_TIMEOUT"></a>IPDR_EVENT_DISCONNECTED_TIMEOUT</em>&nbsp;</td><td>
No ACK within timeout. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga5a163" doxytag="IPDR_EVENT_DISCONNECTED_TCP"></a>IPDR_EVENT_DISCONNECTED_TCP</em>&nbsp;</td><td>
TCP level disconnection (I/O error or remote disconnection). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga5a164" doxytag="IPDR_EVENT_DISCONNECTED_STOP"></a>IPDR_EVENT_DISCONNECTED_STOP</em>&nbsp;</td><td>
Received a "STOP" from collector (server). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga5a165" doxytag="IPDR_EVENT_DISCONNECTED_TOO_SLOW"></a>IPDR_EVENT_DISCONNECTED_TOO_SLOW</em>&nbsp;</td><td>
Collector is ACKing too slowly. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="IPDR.h::IPDR_EventError_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group___i_p_d_r__event__notification.html#ga6">IPDR_EventError_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type of error event. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga6a166" doxytag="IPDR_EVENT_ERROR_UNKNOWN_SERVER"></a>IPDR_EVENT_ERROR_UNKNOWN_SERVER</em>&nbsp;</td><td>
An unknown collector (server) has tried to connect. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga6a167" doxytag="IPDR_EVENT_ERROR_UNKNOWN_SESSION"></a>IPDR_EVENT_ERROR_UNKNOWN_SESSION</em>&nbsp;</td><td>
An unknown session for a collector (server). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga6a168" doxytag="IPDR_EVENT_ERROR_UNEXPECTED_CONNECT"></a>IPDR_EVENT_ERROR_UNEXPECTED_CONNECT</em>&nbsp;</td><td>
Got 2nd connect on an already established connection. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga2" doxytag="IPDR.h::IPDR_EventMsg"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char* IPDR_API_LINKAGE IPDR_EventMsg           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="struct_i_p_d_r___event_data.html">IPDR_EventData</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Explain an event in English, using the information in the event data (there will already be a string with the message; this just uses the <em>EventID</em> and sub-ID (if any) to give a brief string). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Event</em>&nbsp;</td><td>The event, as sent to <a class="el" href="group___i_p_d_r__event__notification.html#ga1">IPDR_EventCallbackDetailed</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A C-string corresponding to the <em>EventID</em> and sub-ID (if any). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="IPDR.h::IPDR_SetExporterEventHandlerDetailed"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_SetExporterEventHandlerDetailed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___i_p_d_r__event__notification.html#ga1">IPDR_EventCallbackDetailed</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>Arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback function which will be used by the transmitter (client) to notify on various events.<p>
Usually the callback will be triggered from within an API function; but in some cases, it can occur asynchronously. The callback is multi-thread safe with all the other API functions; however, the caller may need to provide an additional mutex in the callback for protection from other threads outside the IPDR API.<p>
Applications should not depend on the order of connect, disconnect, or changed events. In particular, it is possible for a single collector (server) to have multiple connect or disconnect events in a row because there can be multiple causes for a connection or disconnection (e.g., a TCP layer reconnection, a "START" message, another collector (server) disconnecting).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to a transmitter (client) previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>argument passed to the <em>Callback</em> function. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon May 30 15:54:42 2005 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
