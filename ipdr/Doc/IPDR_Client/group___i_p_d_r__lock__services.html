<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lock services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Lock services<br>
<small>
[<a class="el" href="group___i_p_d_r__platform.html">Platform abstraction</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_p_d_r___locking_services.html">IPDR_LockingServices</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__lock__services.html#ga0">IPDR_CreateLock_t</a> )(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void **LockPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__lock__services.html#ga1">IPDR_DeleteLock_t</a> )(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void *LockPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__lock__services.html#ga2">IPDR_Lock_t</a> )(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void *LockPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__lock__services.html#ga3">IPDR_Unlock_t</a> )(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void *LockPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__lock__services.html#ga4">IPDR_LockPlatform_t</a> )(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__lock__services.html#ga5">IPDR_UnlockPlatform_t</a> )(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The locking service functions are used by the transmitter (client) to lock critical sections within the code. If the host application is single threaded, NULL pointers should be passed as the function pointers. The IPDR transmitter (client) library assumes that a single lockable entity (such as a single mutex) is locked by the abstraction layer.<p>
There is single "platform" lock which is kept with the platform services; additional locks may be used where needed. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="IPDR.h::IPDR_CreateLock_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(* <a class="el" href="group___i_p_d_r__lock__services.html#ga0">IPDR_CreateLock_t</a>)(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void **LockPtr)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a lock. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The context argument when calling platform function, as passed to <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LockPtr</em>&nbsp;</td><td>(output) The lock (allocated and initialized as necessary). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="IPDR.h::IPDR_DeleteLock_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(* <a class="el" href="group___i_p_d_r__lock__services.html#ga1">IPDR_DeleteLock_t</a>)(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void *LockPtr)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a lock. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The context argument when calling platform function, as passed to <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LockPtr</em>&nbsp;</td><td>The lock (as allocated by <a class="el" href="group___i_p_d_r__lock__services.html#ga0">IPDR_CreateLock_t</a>). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="IPDR.h::IPDR_Lock_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(* <a class="el" href="group___i_p_d_r__lock__services.html#ga2">IPDR_Lock_t</a>)(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void *LockPtr)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain a lock. This function must be reentrant and allow the lock to be obtained recursively (that is, if the same thread tries to obtain the lock twice, it will not deadlock but will wait until the other lock is freed). These semantics are required if socket handling is done by "call backs" (e.g., using the Unix select() or poll() to wait until a socket has data, then doing a read). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The context argument when calling platform function, as passed to <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LockPtr</em>&nbsp;</td><td>The lock (as allocated by <a class="el" href="group___i_p_d_r__lock__services.html#ga0">IPDR_CreateLock_t</a>). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="IPDR.h::IPDR_LockPlatform_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(* <a class="el" href="group___i_p_d_r__lock__services.html#ga4">IPDR_LockPlatform_t</a>)(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock the single platform lock. Usually this is implemented with a pre-allocated lock in the <a class="el" href="group___i_p_d_r__lock__services.html#ga4">IPDR_LockPlatform_t</a> structure. This lock must be recursive, as described with ::IPDR_Lockt_t. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The context argument when calling platform function, as passed to <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LockPtr</em>&nbsp;</td><td>The lock (as allocated by <a class="el" href="group___i_p_d_r__lock__services.html#ga0">IPDR_CreateLock_t</a>). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="IPDR.h::IPDR_Unlock_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(* <a class="el" href="group___i_p_d_r__lock__services.html#ga3">IPDR_Unlock_t</a>)(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P, void *LockPtr)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock a previously locked lock. Unlocking is recursive and symmetric with <a class="el" href="group___i_p_d_r__lock__services.html#ga2">IPDR_Lock_t</a> -- that is, if there are <em>n</em> calls to lock, then there must be <em>n</em> calls to unlock before the lock is released. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The context argument when calling platform function, as passed to <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LockPtr</em>&nbsp;</td><td>The lock (as allocated by <a class="el" href="group___i_p_d_r__lock__services.html#ga0">IPDR_CreateLock_t</a>). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__lock__services.html#ga2">IPDR_Lock_t</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="IPDR.h::IPDR_UnlockPlatform_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group___i_p_d_r__general__typedefs.html#ga0">IPDR_Status</a>(* <a class="el" href="group___i_p_d_r__lock__services.html#ga5">IPDR_UnlockPlatform_t</a>)(<a class="el" href="struct_i_p_d_r__tag___platform_arg.html">IPDR_PlatformArg</a> P)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock the single platform lock. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>The context argument when calling platform function, as passed to <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__lock__services.html#ga4">IPDR_LockPlatform_t</a> </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon May 30 15:54:42 2005 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
