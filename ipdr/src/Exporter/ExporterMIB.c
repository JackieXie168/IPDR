/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.4 2004/07/28 08:04:58 dts12 Exp $
 */

/*
 *  Template MIB group implementation - example.c
 *
 */

#if defined(SNMP_SUPPORT)

/* include important headers */
#include <stdio.h>
#include <net-snmp/net-snmp-config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

/* needed by util_funcs.h */
#if TIME_WITH_SYS_TIME
# ifdef WIN32
#  include <sys/timeb.h>
# else
#  include <sys/time.h>
# endif
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#if HAVE_WINSOCK_H
#include <winsock.h>
#endif
#if HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif

#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_debug.h>

#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif /* HAVE_SIGNAL_H */

#include <net-snmp/agent/mibgroup/util_funcs.h>
#include <Exporter/Templates.h>
#include <Exporter/Version.h>
#include <Exporter/ExporterMsgs.h>

/* For the rcsid's "global" names: */

#include <Exporter/Exporter.h>
#include <Exporter/ExporterConsole.h>
#include <Exporter/ExporterMsgs.h>
#include <Exporter/ExporterProtocol.h>
#include <Exporter/ProtocolDebug.h>
#include <Exporter/Templates.h>
#include <Exporter/Version.h>
#include <Exporter/VolatileQueue.h>
#include <Exporter/VQHandler.h>
#include <Common/ChunksManager.h>
#include <Common/CommonMsgs.h>
#include <Common/CommonUtil.h>
#include <Common/Console.h>
#include <Common/DynamicArray.h>
#include <Common/Log.h>
#include <Common/MemoryManagement.h>
#include <Common/ParametersHandler.h>
#include <Common/Protocol.h>
#include <Platforms/Generic/GenericPlatform.h>
#include <Transports/TCP/TCPMsgs.h>
#include <Transports/TCP/TCPTransport.h>
#include <Common/ConfigurationNames.h>
#include "ExporterMIB.h"

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */
static IPDR_ExporterMIB *ExporterMIB_MIBHandle = NULL;
static SNMP_addCollector SNMPaddCollector = { "", 0, -1, -1 };
static SNMP_removeCollector SNMPremoveCollector = { "" };
static SNMP_addSession SNMPaddSession = { -1, "", "" };
static SNMP_removeSession SNMPremoveSession = { -1 };
static SNMP_assignCollectorToSession SNMPassignCollectorToSession = { -1, "", -1 };
static SNMP_removeCollectorFromSession SNMPremoveCollectorFromSession = { -1, "" };
static SNMP_startSession SNMPstartSession = { -1, -1 };
static SNMP_stopSession SNMPstopSession = { -1, -1, -1 };
static SNMP_reconfigureExporter SNMPreconfigureExporter = { -1 };
static SNMP_commandString SNMPcommandString = { "" };
static SNMP_commandString SNMPcommandResultString = { "" };

typedef int (*SNMPTryCommandHandler)(void* caller);

void SNMPResetAllCommands(void);

int SNMPTryAddCollector(void* caller);
int SNMPTryRemoveCollector(void* caller);
int SNMPTryAddSession(void* caller);
int SNMPTryRemoveSession(void* caller);
int SNMPTryAssignCollectorToSession(void* caller);
int SNMPTryRemoveCollectorFromSession(void* caller);
int SNMPTryStartSession(void* caller);
int SNMPTryStopSession(void* caller);
int SNMPTryReconfigureExporter(void* caller);
int SNMPTryExecCommand(void* caller);

int SNMPSetCommandIPAddressParam(	IPDR_IPAddress ip,
									IPDR_IPAddress* param,
									SNMPTryCommandHandler handler);
int SNMPSetCommandIntegerParam(		int value,
									int* param,
									SNMPTryCommandHandler handler);
int SNMPSetCommandStringParam(		char* value,
									char* param,
									SNMPTryCommandHandler handler);

IPDR_IPAddress ExporterMIB_ParseIP(const char* ip_str);
char* ExporterMIB_BuildIP(IPDR_IPAddress ip_num, char* ip_str);

int
ExporterMIB__IntegerConfigHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests,
						  const char* valueName);
int
ExporterMIB__IPAddressConfigHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests,
						  const char* valueName);
int
ExporterMIB__StringConfigHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests,
						  const char* valueName);

int
ExporterMIB__IntegerCommandHandler(netsnmp_mib_handler	*handler,
                          netsnmp_handler_registration	*reginfo,
                          netsnmp_agent_request_info	*reqinfo,
                          netsnmp_request_info			*requests,
						  int							*param,
						  SNMPTryCommandHandler			commandHandler);
int
ExporterMIB__IPAddressCommandHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration	*reginfo,
                          netsnmp_agent_request_info	*reqinfo,
                          netsnmp_request_info			*requests,
						  IPDR_IPAddress				*param,
						  SNMPTryCommandHandler			commandHandler);
int
ExporterMIB__StringCommandHandler(netsnmp_mib_handler	*handler,
                          netsnmp_handler_registration	*reginfo,
                          netsnmp_agent_request_info	*reqinfo,
                          netsnmp_request_info			*requests,
						  char							*param,
						  SNMPTryCommandHandler			commandHandler);

void SNMPResetAllCommands(void)
{
	SNMPaddCollector.addCollectorName[0] = '\0' ;
	SNMPaddCollector.addCollectorAddress = 0 ;
	SNMPaddCollector.addCollectorPort = -1 ;
	SNMPaddCollector.addCollectorConnections = -1 ;

	SNMPremoveCollector.removeCollectorName[0] = '\0' ;

	SNMPaddSession.addSessionName[0] = '\0' ;
	SNMPaddSession.addSessionID = -1 ;
	SNMPaddSession.addSessionDescription[0] = '\0' ;

	SNMPremoveSession.removeSessionID = -1 ;

	SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
	SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
	SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;

	SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
	SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;

	SNMPreconfigureExporter.reconfigureExporter = -1 ;
}

int SNMPTryExecCommand(void* caller)
{
	static void *p_string = SNMPcommandString.string;
	if(caller == p_string)
	{
		if(strlen(SNMPcommandString.string) > 0)
			;
	}
	else
	{
		return 0 ;
	}

	if(FAILURE(IPDR_DoConsoleCommand(ExporterMIB_MIBHandle->ExporterHandle,
									NULL,SNMPcommandString.string,
									NULL, NULL, NULL,NULL,
									SNMPcommandResultString.string,
									ASN_COMAND_STR_SIZE)))
	{
		SNMPcommandString.string[0] = '\0' ;
		return 0 ;
	}

	SNMPcommandString.string[0] = '\0' ;
	return 1 ;
}

int SNMPTryAddCollector(void* caller)
{
	static void *p_addCollectorName = SNMPaddCollector.addCollectorName;
	static void *p_addCollectorAddress = &(SNMPaddCollector.addCollectorAddress);
	static void *p_addCollectorPort = &(SNMPaddCollector.addCollectorPort);
	static void *p_addCollectorConnections = &(SNMPaddCollector.addCollectorConnections);

	if(caller == p_addCollectorName)
	{
		if(	strlen(SNMPaddCollector.addCollectorName) > 0 &&
			SNMPaddCollector.addCollectorAddress == 0 &&
			SNMPaddCollector.addCollectorPort == -1 &&
			SNMPaddCollector.addCollectorConnections == -1	)
		{
			return 1 ;
		}
		else
		{
			SNMPaddCollector.addCollectorName[0] = '\0' ;
			SNMPaddCollector.addCollectorAddress = 0 ;
			SNMPaddCollector.addCollectorPort = -1 ;
			SNMPaddCollector.addCollectorConnections = -1 ;
			return 0 ;
		}
	}
	else if (caller == p_addCollectorAddress)
	{
		if(	strlen(SNMPaddCollector.addCollectorName) > 0 &&
			SNMPaddCollector.addCollectorAddress != 0 &&
			SNMPaddCollector.addCollectorPort == -1 &&
			SNMPaddCollector.addCollectorConnections == -1	)
		{
			return 1 ;
		}
		else
		{
			SNMPaddCollector.addCollectorName[0] = '\0' ;
			SNMPaddCollector.addCollectorAddress = 0 ;
			SNMPaddCollector.addCollectorPort = -1 ;
			SNMPaddCollector.addCollectorConnections = -1 ;
			return 0 ;
		}
	}
	else if (caller == p_addCollectorPort)
	{
		if(	strlen(SNMPaddCollector.addCollectorName) > 0 &&
			SNMPaddCollector.addCollectorAddress != 0 &&
			SNMPaddCollector.addCollectorPort != -1 &&
			SNMPaddCollector.addCollectorConnections == -1	)
		{
			return 1 ;
		}
		else
		{
			SNMPaddCollector.addCollectorName[0] = '\0' ;
			SNMPaddCollector.addCollectorAddress = 0 ;
			SNMPaddCollector.addCollectorPort = -1 ;
			SNMPaddCollector.addCollectorConnections = -1 ;
			return 0 ;
		}
	}
	else if (caller == p_addCollectorConnections)
	{
		if(	strlen(SNMPaddCollector.addCollectorName) > 0 &&
			SNMPaddCollector.addCollectorAddress != 0 &&
			SNMPaddCollector.addCollectorPort != -1 &&
			SNMPaddCollector.addCollectorConnections != -1	)
		{
			 ;
		}
		else
		{
			SNMPaddCollector.addCollectorName[0] = '\0' ;
			SNMPaddCollector.addCollectorAddress = 0 ;
			SNMPaddCollector.addCollectorPort = -1 ;
			SNMPaddCollector.addCollectorConnections = -1 ;
			return 0 ;
		}
	}
	else
	{
		SNMPaddCollector.addCollectorName[0] = '\0' ;
		SNMPaddCollector.addCollectorAddress = 0 ;
		SNMPaddCollector.addCollectorPort = -1 ;
		SNMPaddCollector.addCollectorConnections = -1 ;
		return 0 ;
	}

	if(FAILURE(IPDR_CreateCollector(
						ExporterMIB_MIBHandle->ExporterHandle,
						SNMPaddCollector.addCollectorName,
						SNMPaddCollector.addCollectorAddress,
						SNMPaddCollector.addCollectorPort,
						SNMPaddCollector.addCollectorConnections,
						NULL)))
	{
		SNMPaddCollector.addCollectorName[0] = '\0' ;
		SNMPaddCollector.addCollectorAddress = 0 ;
		SNMPaddCollector.addCollectorPort = -1 ;
		SNMPaddCollector.addCollectorConnections = -1 ;
		return 0 ;
	}

	SNMPaddCollector.addCollectorName[0] = '\0' ;
	SNMPaddCollector.addCollectorAddress = 0 ;
	SNMPaddCollector.addCollectorPort = -1 ;
	SNMPaddCollector.addCollectorConnections = -1 ;
	return 1 ;
}
int SNMPTryRemoveCollector(void* caller)
{
	IPDR_CollectorHandle CH ;

	static void *p_removeCollectorName = SNMPremoveCollector.removeCollectorName;

	if(caller == p_removeCollectorName)
	{
		if(	strlen(SNMPremoveCollector.removeCollectorName) > 0 )
		{
			;
		}
		else
		{
			SNMPremoveCollector.removeCollectorName[0] = '\0' ;
			return 0 ;
		}
	}
	else
	{
		SNMPremoveCollector.removeCollectorName[0] = '\0' ;
		return 0 ;
	}

	if(FAILURE(IPDR_GetCollector(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPremoveCollector.removeCollectorName,
								& CH,
                                NULL,
								NULL,
								NULL)))
	{
		SNMPremoveCollector.removeCollectorName[0] = '\0' ;
		return 0 ;
	}

	if(FAILURE(IPDR_RemoveCollector(ExporterMIB_MIBHandle->ExporterHandle,
                   				CH)))
	{
		SNMPremoveCollector.removeCollectorName[0] = '\0' ;
		return 0 ;
	}

	SNMPremoveCollector.removeCollectorName[0] = '\0' ;
	return 1 ;
}
int SNMPTryAddSession(void* caller)
{
	static void *p_addSessionID = &(SNMPaddSession.addSessionID);
	static void *p_addSessionName = SNMPaddSession.addSessionName;
	static void *p_addSessionDescription = SNMPaddSession.addSessionDescription;

	IPDR_SessionHandle SH;

	if(caller == p_addSessionID)
	{
		if(	SNMPaddSession.addSessionID != -1 &&
			strlen(SNMPaddSession.addSessionName) == 0 &&
			strlen(SNMPaddSession.addSessionDescription) == 0)
		{
			return 1 ;
		}
		else
		{
			SNMPaddSession.addSessionName[0] = '\0' ;
			SNMPaddSession.addSessionID = -1 ;
			SNMPaddSession.addSessionDescription[0] = '\0' ;
			return 0 ;
		}
	}
	else if(caller == p_addSessionName)
	{
		if(	SNMPaddSession.addSessionID != -1 &&
			strlen(SNMPaddSession.addSessionName) > 0 &&
			strlen(SNMPaddSession.addSessionDescription) == 0)
		{
			return 1 ;
		}
		else
		{
			SNMPaddSession.addSessionName[0] = '\0' ;
			SNMPaddSession.addSessionID = -1 ;
			SNMPaddSession.addSessionDescription[0] = '\0' ;
			return 0 ;
		}
	}
	else if(caller == p_addSessionDescription)
	{
		if(	SNMPaddSession.addSessionID != -1 &&
			strlen(SNMPaddSession.addSessionName) > 0 &&
			strlen(SNMPaddSession.addSessionDescription) > 0)
		{
			  ;
		}
		else
		{
			SNMPaddSession.addSessionName[0] = '\0' ;
			SNMPaddSession.addSessionID = -1 ;
			SNMPaddSession.addSessionDescription[0] = '\0' ;
			return 0 ;
		}
	}
	else
	{
		SNMPaddSession.addSessionName[0] = '\0' ;
		SNMPaddSession.addSessionID = -1 ;
		SNMPaddSession.addSessionDescription[0] = '\0' ;
		return 0 ;
	}

    if(FAILURE(IPDR_CreateSession(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPaddSession.addSessionName,
								SNMPaddSession.addSessionID,
                                SNMPaddSession.addSessionDescription,
								&SH)))
	{
		SNMPaddSession.addSessionName[0] = '\0' ;
		SNMPaddSession.addSessionID = -1 ;
		SNMPaddSession.addSessionDescription[0] = '\0' ;
		return 0 ;
	}

	SNMPaddSession.addSessionName[0] = '\0' ;
	SNMPaddSession.addSessionID = -1 ;
	SNMPaddSession.addSessionDescription[0] = '\0' ;
	return 1 ;
}
int SNMPTryRemoveSession(void* caller)
{
	static void *p_removeSessionID = &(SNMPremoveSession.removeSessionID);

	IPDR_SessionHandle SH;

	if(caller == p_removeSessionID)
	{
		if(	SNMPremoveSession.removeSessionID != -1 )
		{
			;
		}
		else
		{
			SNMPremoveSession.removeSessionID = -1 ;
			return 0 ;
		}
	}
	else
	{
		SNMPremoveSession.removeSessionID = -1 ;
		return 0 ;
	}

	if(FAILURE(IPDR_GetSession(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPremoveSession.removeSessionID,
								& SH,
								NULL,
								NULL)))
	{
		SNMPremoveSession.removeSessionID = -1 ;
		return 0 ;
	}

	if(FAILURE(IPDR_DeleteSession(ExporterMIB_MIBHandle->ExporterHandle,
								SH)))
	{
		SNMPremoveSession.removeSessionID = -1 ;
		return 0 ;
	}

	SNMPremoveSession.removeSessionID = -1 ;
	return 1 ;
}
int SNMPTryAssignCollectorToSession(void* caller)
{
	static void *p_assignCollectorSessionID = &(SNMPassignCollectorToSession.assignCollectorSessionID);
	static void *p_assignCollectorName = SNMPassignCollectorToSession.assignCollectorName;
	static void *p_assignCollectorPrioriry = &(SNMPassignCollectorToSession.assignCollectorPrioriry);

	IPDR_SessionHandle SH;
	IPDR_CollectorHandle CH ;

	if(caller == p_assignCollectorSessionID)
	{
		if(	SNMPassignCollectorToSession.assignCollectorSessionID != -1 &&
			strlen(SNMPassignCollectorToSession.assignCollectorName) == 0 &&
			SNMPassignCollectorToSession.assignCollectorPrioriry == -1)
		{
			return 1 ;
		}
		else
		{
			SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
			SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
			SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
			return 0 ;
		}
	}
	else if(caller == p_assignCollectorName)
	{
		if(	SNMPassignCollectorToSession.assignCollectorSessionID != -1 &&
			strlen(SNMPassignCollectorToSession.assignCollectorName) > 0 &&
			SNMPassignCollectorToSession.assignCollectorPrioriry == -1)
		{
			return 1 ;
		}
		else
		{
			SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
			SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
			SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
			return 0 ;
		}
	}
	else if(caller == p_assignCollectorPrioriry)
	{
		if(	SNMPassignCollectorToSession.assignCollectorSessionID != -1 &&
			strlen(SNMPassignCollectorToSession.assignCollectorName) > 0 &&
			SNMPassignCollectorToSession.assignCollectorPrioriry != -1)
		{
			 ;
		}
		else
		{
			SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
			SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
			SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
			return 0 ;
		}
	}
	else
	{
		SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
		SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
		SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
		return 0 ;
	}

    if(FAILURE(IPDR_GetCollector(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPassignCollectorToSession.assignCollectorName,
								& CH,
                                NULL,
								NULL,
								NULL)))
	{
		SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
		SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
		SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
		return 0 ;
	}

	if(FAILURE(IPDR_GetSession(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPassignCollectorToSession.assignCollectorSessionID,
								& SH,
                                NULL,
								NULL)))
	{
		SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
		SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
		SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
		return 0 ;
	}

	if(FAILURE(IPDR_AssocCollectorSession(ExporterMIB_MIBHandle->ExporterHandle,
								SH,
                                CH,
								SNMPassignCollectorToSession.assignCollectorPrioriry)))
	{
		SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
		SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
		SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
		return 0 ;
	}

	SNMPassignCollectorToSession.assignCollectorSessionID = -1 ;
	SNMPassignCollectorToSession.assignCollectorName[0] = '\0' ;
	SNMPassignCollectorToSession.assignCollectorPrioriry = -1 ;
	return 1 ;
}
int SNMPTryRemoveCollectorFromSession(void* caller)
{
	static void *p_removeCollectorSessionID = &(SNMPremoveCollectorFromSession.removeCollectorSessionID);
	static void *p_removeCollectorSessionName = SNMPremoveCollectorFromSession.removeCollectorSessionName;

	IPDR_SessionHandle SH;
	IPDR_CollectorHandle CH ;

	if(caller == p_removeCollectorSessionID)
	{
		if(	SNMPremoveCollectorFromSession.removeCollectorSessionID != -1 &&
			strlen(SNMPremoveCollectorFromSession.removeCollectorSessionName) == 0)
		{
			return 1 ;
		}
		else
		{
			SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
			SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
			return 0 ;
		}
	}
	else if(caller == p_removeCollectorSessionName)
	{
		if(	SNMPremoveCollectorFromSession.removeCollectorSessionID != -1 &&
			strlen(SNMPremoveCollectorFromSession.removeCollectorSessionName) > 0)
		{
			;
		}
		else
		{
			SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
			SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
			return 0 ;
		}
	}
	else
	{
		SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
		SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
		return 0 ;
	}

    if(FAILURE(IPDR_GetCollector(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPremoveCollectorFromSession.removeCollectorSessionName,
								& CH,
                                NULL,
								NULL,
								NULL)))
	{
		SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
		SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
		return 0 ;
	}

	if(FAILURE(IPDR_GetSession(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPremoveCollectorFromSession.removeCollectorSessionID,
								& SH,
                                NULL,
								NULL)))
	{
		SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
		SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
		return 0 ;
	}

	if(FAILURE(IPDR_RemoveCollectorFromSession(ExporterMIB_MIBHandle->ExporterHandle,
								SH,
                                CH)))
	{
		SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
		SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
		return 0 ;
	}

	SNMPremoveCollectorFromSession.removeCollectorSessionID = -1 ;
	SNMPremoveCollectorFromSession.removeCollectorSessionName[0] = '\0' ;
	return 1 ;
}

int SNMPTryStartSession(void* caller)
{
	static void *p_startSessionID = &(SNMPstartSession.startSessionID);
	static void *p_startSessionNegotiate = &(SNMPstartSession.startSessionNegotiate);

	IPDR_SessionHandle SH;

	if(caller == p_startSessionID)
	{
		if(	SNMPstartSession.startSessionID != -1 &&
			SNMPstartSession.startSessionNegotiate == -1)
		{
			return 1 ;
		}
		else
		{
			SNMPstartSession.startSessionID = -1;
			SNMPstartSession.startSessionNegotiate = -1;
			return 0 ;
		}
	}
	else if(caller == p_startSessionNegotiate)
	{
		if(	SNMPstartSession.startSessionID != -1 &&
			SNMPstartSession.startSessionNegotiate != -1)
		{
			;
		}
		else
		{
			SNMPstartSession.startSessionID = -1;
			SNMPstartSession.startSessionNegotiate = -1;
			return 0 ;
		}
	}
	else
	{
		SNMPstartSession.startSessionID = -1;
		SNMPstartSession.startSessionNegotiate = -1;
		return 0 ;
	}

	if(FAILURE(IPDR_GetSession(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPstartSession.startSessionID,
								& SH,
								NULL,
								NULL)))
	{
		SNMPstartSession.startSessionID = -1;
		SNMPstartSession.startSessionNegotiate = -1;
		return 0 ;
	}

	if(FAILURE(IPDR_StartSession(SH, SNMPstartSession.startSessionNegotiate)))
	{
		SNMPstartSession.startSessionID = -1;
		SNMPstartSession.startSessionNegotiate = -1;
		return 0 ;
	}

	SNMPstartSession.startSessionID = -1;
	SNMPstartSession.startSessionNegotiate = -1;
	return 1 ;
}
int SNMPTryStopSession(void* caller)
{
	static void *p_stopSessionID = &(SNMPstopSession.stopSessionID);
	static void *p_stopSessionReason = &(SNMPstopSession.stopSessionReason);
	static void *p_stopSessionTimeout = &(SNMPstopSession.stopSessionTimeout);

	IPDR_SessionHandle SH;

	if(caller == p_stopSessionID)
	{
		if(	SNMPstopSession.stopSessionID != -1 &&
			SNMPstopSession.stopSessionReason == -1 &&
			SNMPstopSession.stopSessionTimeout == -1 )
		{
			return 1;
		}
		else
		{
			SNMPstopSession.stopSessionID = -1 ;
			SNMPstopSession.stopSessionReason = -1;
			SNMPstopSession.stopSessionTimeout = -1;
			return 0 ;
		}
	}
	else if(caller == p_stopSessionReason)
	{
		if(	SNMPstopSession.stopSessionID != -1 &&
			SNMPstopSession.stopSessionReason != -1 &&
			SNMPstopSession.stopSessionTimeout == -1 )
		{
			return 1;
		}
		else
		{
			SNMPstopSession.stopSessionID = -1 ;
			SNMPstopSession.stopSessionReason = -1;
			SNMPstopSession.stopSessionTimeout = -1;
			return 0 ;
		}
	}
	else if(caller == p_stopSessionTimeout)
	{
		if(	SNMPstopSession.stopSessionID != -1 &&
			SNMPstopSession.stopSessionReason != -1 &&
			SNMPstopSession.stopSessionTimeout != -1 )
		{
			;
		}
		else
		{
			SNMPstopSession.stopSessionID = -1 ;
			SNMPstopSession.stopSessionReason = -1;
			SNMPstopSession.stopSessionTimeout = -1;
			return 0 ;
		}
	}
	else
	{
		SNMPstopSession.stopSessionID = -1 ;
		SNMPstopSession.stopSessionReason = -1;
		SNMPstopSession.stopSessionTimeout = -1;
		return 0 ;
	}

	if(FAILURE(IPDR_GetSession(ExporterMIB_MIBHandle->ExporterHandle,
								SNMPstopSession.stopSessionID,
								& SH,
								NULL,
								NULL)))
	{
		SNMPstopSession.stopSessionID = -1 ;
		SNMPstopSession.stopSessionReason = -1;
		SNMPstopSession.stopSessionTimeout = -1;
		return 0 ;
	}

	if(FAILURE(IPDR_StopSession(SH,
					SNMPstopSession.stopSessionReason,
					SNMPstopSession.stopSessionTimeout)))
	{
		SNMPstopSession.stopSessionID = -1 ;
		SNMPstopSession.stopSessionReason = -1;
		SNMPstopSession.stopSessionTimeout = -1;
		return 0 ;
	}

	SNMPstopSession.stopSessionID = -1 ;
	SNMPstopSession.stopSessionReason = -1;
	SNMPstopSession.stopSessionTimeout = -1;
	return 1 ;
}
int SNMPTryReconfigureExporter(void* caller)
{
	static void *p_reconfigureExporter = &(SNMPreconfigureExporter.reconfigureExporter);

	if(caller == p_reconfigureExporter)
	{
		if(	SNMPreconfigureExporter.reconfigureExporter != -1 )
		{
			;
		}
		else
		{
			SNMPreconfigureExporter.reconfigureExporter = -1;
			return 0 ;
		}
	}
	else
	{
		SNMPreconfigureExporter.reconfigureExporter = -1;
		return 0 ;
	}

	if(FAILURE(IPDR_ReconfigExporter(ExporterMIB_MIBHandle->ExporterHandle)))
	{
		SNMPreconfigureExporter.reconfigureExporter = -1;
		return 0 ;
	}

	SNMPreconfigureExporter.reconfigureExporter = -1;
	return 1 ;
}

int SNMPSetCommandIPAddressParam(	IPDR_IPAddress ip,
									IPDR_IPAddress* param,
									SNMPTryCommandHandler handler)
{
	(*param) = ip ;
	return handler(param);
}
int SNMPSetCommandIntegerParam(		int value,
									int* param,
									SNMPTryCommandHandler handler)
{
	(*param) = value ;
	return handler(param);
}
int SNMPSetCommandStringParam(		char* value,
									char* param,
									SNMPTryCommandHandler handler)
{
	strncpy(param, value, ASN_VAR_STR_SIZE);
	return handler(param);
}

IPDR_IPAddress ExporterMIB_ParseIP(const char* ip_str)
{
    IPDR_IPAddress Bytes[4];
    IPDR_IPAddress Res;

	if( ip_str )
    	sscanf(ip_str, "%u.%u.%u.%u", & Bytes[0], & Bytes[1], & Bytes[2], & Bytes[3]);
	else
		Bytes[0] = Bytes[1] = Bytes[2] = Bytes[3] = 0;
    Res = (Bytes[0] << 24) | (Bytes[1] << 16) | (Bytes[2] << 8) | Bytes[3];
    return Res;
}
char* ExporterMIB_BuildIP(IPDR_IPAddress ip_num, char* ip_str)
{
	sprintf(ip_str, "%u.%u.%u.%u",
            (ip_num>>24) & 0xffu,
            (ip_num>>16) & 0xffu,
            (ip_num>> 8) & 0xffu,
            (ip_num>> 0) & 0xffu);

    return ip_str;
}

int
ExporterMIB__IntegerConfigHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests,
						  const char* valueName)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	SNMPResetAllCommands();

    switch(reqinfo->mode) {

        case MODE_GET:
			{
				int value = 0;
				char value_str[ASN_SMALTYPE_STR_SIZE];
				if(FAILURE(IPDR_ParamGet(
							ExporterMIB_MIBHandle->ExporterHandle,
							valueName,
							value_str, ASN_SMALTYPE_STR_SIZE)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				value = atoi(value_str);
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
										(u_char *) &value, ASN_INTEGER_SIZE);
			}
            break;
        case MODE_SET_RESERVE1:
            if (netsnmp_check_vb_type_and_size(requests->requestvb,
									ASN_INTEGER, ASN_INTEGER_SIZE)
													!= SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            {
				int value = 0;
				int *accesses_cache = NULL;
				char value_str[ASN_SMALTYPE_STR_SIZE];

				if(FAILURE(IPDR_ParamGet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								value_str, ASN_SMALTYPE_STR_SIZE)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}

				value = atoi(value_str);

				memdup((u_char **) & accesses_cache,
						(u_char *) & value, sizeof(value));

				if (accesses_cache == NULL)
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				netsnmp_request_add_list_data(requests,
											netsnmp_create_data_list
											(handler->handler_name,
											accesses_cache, free));
			}
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				char value_str[ASN_SMALTYPE_STR_SIZE];
				int value = *(requests->requestvb->val.integer);
				snprintf(value_str, ASN_SMALTYPE_STR_SIZE, "%u", value);
				if(FAILURE(IPDR_ParamSet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								value_str)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
			{
				char value_str[ASN_SMALTYPE_STR_SIZE];
				int value =
							*((int *)
							netsnmp_request_get_list_data(
														requests,
														handler->handler_name));
				snprintf(value_str, ASN_SMALTYPE_STR_SIZE, "%u", value);
				if(FAILURE(IPDR_ParamSet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								value_str)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode, handler->handler_name );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
ExporterMIB__IPAddressConfigHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests,
						  const char* valueName)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	SNMPResetAllCommands();

	switch( reqinfo->mode ) {

        case MODE_GET:
			{
				IPDR_IPAddress ip = 0;
				char ip_str[ASN_BIGTYPE_STR_SIZE];
				if(FAILURE(IPDR_ParamGet(
							ExporterMIB_MIBHandle->ExporterHandle,
							valueName,
							ip_str, ASN_BIGTYPE_STR_SIZE)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}

				ip = htonl(ExporterMIB_ParseIP(ip_str));
				snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
			                            (u_char *) &ip, ASN_IPADDRESS_SIZE);
			}
            break;
        case MODE_SET_RESERVE1:
            if (netsnmp_check_vb_type_and_size(requests->requestvb,
									ASN_IPADDRESS, ASN_IPADDRESS_SIZE)
													!= SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        case MODE_SET_RESERVE2:
            {
				IPDR_IPAddress ip = 0;
				IPDR_IPAddress	*accesses_cache = NULL;
				char ip_str[ASN_BIGTYPE_STR_SIZE];

				if(FAILURE(IPDR_ParamGet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								ip_str, ASN_BIGTYPE_STR_SIZE)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}

				ip = ExporterMIB_ParseIP(ip_str);

				memdup((u_char **) & accesses_cache,
						(u_char *) & ip, sizeof(ip));

				if (accesses_cache == NULL)
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				netsnmp_request_add_list_data(requests,
											netsnmp_create_data_list
											(handler->handler_name,
											accesses_cache, free));
			}
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				char ip_str[ASN_BIGTYPE_STR_SIZE];
				IPDR_IPAddress ip = ntohl(*(requests->requestvb->val.integer));

				if(FAILURE(IPDR_ParamSet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								ExporterMIB_BuildIP(ip, ip_str))))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        case MODE_SET_COMMIT:
			break;

        case MODE_SET_UNDO:
			{
				char ip_str[ASN_BIGTYPE_STR_SIZE];
				IPDR_IPAddress ip =
							*((IPDR_IPAddress *)
							netsnmp_request_get_list_data(
														requests,
														handler->handler_name));
				if(FAILURE(IPDR_ParamSet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								ExporterMIB_BuildIP(ip, ip_str))))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode, handler->handler_name );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
ExporterMIB__StringConfigHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests,
						  const char* valueName)
{
	    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	SNMPResetAllCommands();

    switch(reqinfo->mode) {

        case MODE_GET:
			{
				char value_str[ASN_VAR_STR_SIZE];
				if(FAILURE(IPDR_ParamGet(
							ExporterMIB_MIBHandle->ExporterHandle,
							valueName,
							value_str, ASN_VAR_STR_SIZE)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}

				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
			                            (u_char *) &value_str, strlen(value_str));
			}
            break;
        case MODE_SET_RESERVE1:
            if (netsnmp_check_vb_type(requests->requestvb,
									ASN_OCTET_STR)
													!= SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
		case MODE_SET_RESERVE2:
            {
				char *accesses_cache = NULL;
				char value_str[ASN_VAR_STR_SIZE];

				if(FAILURE(IPDR_ParamGet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								value_str, ASN_VAR_STR_SIZE)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}

				memdup((u_char **) & accesses_cache,
						(u_char *) value_str, sizeof(value_str));

				if (accesses_cache == NULL)
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				netsnmp_request_add_list_data(requests,
											netsnmp_create_data_list
											(handler->handler_name,
											accesses_cache, free));
			}
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				char *accesses_cache = requests->requestvb->val.string;

				if(FAILURE(IPDR_ParamSet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								accesses_cache)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
			{
				char *accesses_cache = (char *)netsnmp_request_get_list_data(
														requests,
														handler->handler_name);
				if(FAILURE(IPDR_ParamSet(
								ExporterMIB_MIBHandle->ExporterHandle,
								valueName,
								accesses_cache)))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
			break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode, handler->handler_name );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
ExporterMIB__IntegerCommandHandler(netsnmp_mib_handler	*handler,
                          netsnmp_handler_registration	*reginfo,
                          netsnmp_agent_request_info	*reqinfo,
                          netsnmp_request_info			*requests,
						  int							*param,
						  SNMPTryCommandHandler			commandHandler)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
			{
				int value = *param;
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
										(u_char *) &value, ASN_INTEGER_SIZE);
			}
            break;
        case MODE_SET_RESERVE1:
            if (netsnmp_check_vb_type_and_size(requests->requestvb,
									ASN_INTEGER, ASN_INTEGER_SIZE)
													!= SNMP_ERR_NOERROR)
			{
				SNMPSetCommandIntegerParam(	-1, param, commandHandler);
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            {
				int value = *param;
				int *accesses_cache = NULL;

				memdup((u_char **) & accesses_cache,
						(u_char *) & value, sizeof(value));

				if (accesses_cache == NULL)
				{
					SNMPSetCommandIntegerParam(	-1, param, commandHandler);
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				netsnmp_request_add_list_data(requests,
											netsnmp_create_data_list
											(handler->handler_name,
											accesses_cache, free));
			}
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				int value = *(requests->requestvb->val.integer);
				if(!SNMPSetCommandIntegerParam(	value,
												param,
												commandHandler))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
			{
				int value =
							*((int *)
							netsnmp_request_get_list_data(
														requests,
														handler->handler_name));
				if(!SNMPSetCommandIntegerParam(	value,
												param,
												commandHandler))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode, handler->handler_name );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
ExporterMIB__IPAddressCommandHandler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration	*reginfo,
                          netsnmp_agent_request_info	*reqinfo,
                          netsnmp_request_info			*requests,
						  IPDR_IPAddress				*param,
						  SNMPTryCommandHandler			commandHandler)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
			{
				IPDR_IPAddress value = htonl(*param);
				snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
										(u_char *) &value, ASN_IPADDRESS_SIZE);
			}
            break;
        case MODE_SET_RESERVE1:
            if (netsnmp_check_vb_type_and_size(requests->requestvb,
									ASN_IPADDRESS, ASN_IPADDRESS_SIZE)
													!= SNMP_ERR_NOERROR)
			{
				SNMPSetCommandIPAddressParam(	0, param, commandHandler);
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            {
				IPDR_IPAddress value = *param;
				IPDR_IPAddress *accesses_cache = NULL;

				memdup((u_char **) & accesses_cache,
						(u_char *) & value, sizeof(value));

				if (accesses_cache == NULL)
				{
					SNMPSetCommandIPAddressParam(	0, param, commandHandler);
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				netsnmp_request_add_list_data(requests,
											netsnmp_create_data_list
											(handler->handler_name,
											accesses_cache, free));
			}
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				IPDR_IPAddress value = htonl(*(requests->requestvb->val.integer));
				if(!SNMPSetCommandIPAddressParam(	value,
													param,
													commandHandler))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
			{
				IPDR_IPAddress value =
							*((int *)
							netsnmp_request_get_list_data(
														requests,
														handler->handler_name));

				if(!SNMPSetCommandIPAddressParam(	value,
													param,
													commandHandler))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode, handler->handler_name );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
ExporterMIB__StringCommandHandler(netsnmp_mib_handler	*handler,
                          netsnmp_handler_registration	*reginfo,
                          netsnmp_agent_request_info	*reqinfo,
                          netsnmp_request_info			*requests,
						  char							*param,
						  SNMPTryCommandHandler			commandHandler)
{
		    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
			{
				char value_str[ASN_VAR_STR_SIZE];
				strncpy(value_str, param, 	ASN_VAR_STR_SIZE);

				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
			                            (u_char *) &value_str, strlen(value_str));
			}
            break;
        case MODE_SET_RESERVE1:
			{
				char value_str[ASN_VAR_STR_SIZE];
				if (netsnmp_check_vb_type(requests->requestvb,
										ASN_OCTET_STR)
														!= SNMP_ERR_NOERROR)
				{
					value_str[0] = '\0';
					SNMPSetCommandStringParam(	value_str, param, commandHandler);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
				}
			}
			break;
		case MODE_SET_RESERVE2:
            {
				char *accesses_cache = NULL;
				char value_str[ASN_VAR_STR_SIZE];

				strncpy(value_str, param, 	ASN_VAR_STR_SIZE);

				memdup((u_char **) & accesses_cache,
						(u_char *) value_str, sizeof(value_str));

				if (accesses_cache == NULL)
				{
					value_str[0] = '\0';
					SNMPSetCommandStringParam(	value_str, param, commandHandler);
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
				netsnmp_request_add_list_data(requests,
											netsnmp_create_data_list
											(handler->handler_name,
											accesses_cache, free));
			}
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				char *accesses_cache = requests->requestvb->val.string;

				if(!SNMPSetCommandStringParam(	accesses_cache, param, commandHandler))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
			{
				char *accesses_cache = (char *)netsnmp_request_get_list_data(
														requests,
														handler->handler_name);

				if(!SNMPSetCommandStringParam(	accesses_cache, param, commandHandler))
				{
					netsnmp_set_request_error(reqinfo, requests,
											SNMP_ERR_RESOURCEUNAVAILABLE);
				}
			}
			break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in %s\n", reqinfo->mode, handler->handler_name );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

}

RETSIGTYPE
ExporterMIB_StopMibServer(int a) {
    ExporterMIB_MIBHandle->Running = 0;
}


void *ExporterMIB_MIBMainFunc(void *P)
{
	ExporterMIB_MIBHandle = (IPDR_ExporterMIB *)P;
  /* print log errors to stderr */
  snmp_enable_stderrlog();
 /* we are a subagent */
  netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 1);

  /* initialize the agent library */
  init_agent("IPDR");

  /* initialize your mib code here */
  init_exporterScalar();

  /* ustMain will be used to read ustMain.conf files. */
  init_snmp("IPDR");

  /* In case we recevie a request to stop (kill -TERM or kill -INT) */
  ExporterMIB_MIBHandle->Running = 1;
#ifdef SIGTERM
  signal(SIGTERM, ExporterMIB_StopMibServer);
#endif
#ifdef SIGINT
  signal(SIGINT, ExporterMIB_StopMibServer);
#endif
  /* main loop here... */
  while(ExporterMIB_MIBHandle->Running) {
    agent_check_and_process(1);
  }

  /* at shutdown time */
  snmp_shutdown("IPDR");

  return NULL ;
}

/** Initializes the exporter module */
void
init_exporterScalar(void)
{
    static oid exporterAddress_oid[] = { 1,3,6,1,4,1,9334,1,7,1 };
    static oid exporterPort_oid[] = { 1,3,6,1,4,1,9334,1,7,2 };
    static oid vendorString_oid[] = { 1,3,6,1,4,1,9334,1,7,4 };
    static oid consolePort_oid[] = { 1,3,6,1,4,1,9334,1,7,5,1 };
    static oid consolePassword_oid[] = { 1,3,6,1,4,1,9334,1,7,5,2 };
    static oid loggerAddress_oid[] = { 1,3,6,1,4,1,9334,1,7,6,1 };
    static oid loggerPort_oid[] = { 1,3,6,1,4,1,9334,1,7,6,2 };
    static oid moduleExporter_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,1 };
    static oid moduleQueue_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,2 };
    static oid moduleTCP_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,3 };
    static oid moduleMemory_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,4 };
    static oid moduleProtocol_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,5 };
    static oid modulePlatform_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,6 };
    static oid moduleHost_oid[] = { 1,3,6,1,4,1,9334,1,7,6,3,7 };
    static oid windowSize_oid[] = { 1,3,6,1,4,1,9334,1,7,7 };
    static oid windowTimeout_oid[] = { 1,3,6,1,4,1,9334,1,7,8 };
    static oid templateAckTimeout_oid[] = { 1,3,6,1,4,1,9334,1,7,9 };
    static oid statisticsInterval_oid[] = { 1,3,6,1,4,1,9334,1,7,10 };
    static oid dataRcvChunkSize_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,1 };
    static oid dataRcvMaxMemory_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,2 };
    static oid dataRcvInitialNumChunks_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,3 };
    static oid dataSndChunkSize_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,4 };
    static oid dataSndMaxMemory_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,5 };
    static oid dataSndInitialNumChunks_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,6 };
    static oid sendBuffersChunkSize_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,7 };
    static oid sendBuffersMaxMemory_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,8 };
    static oid sendBuffersInitialNumChunks_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,9 };
    static oid flushInterval_oid[] = { 1,3,6,1,4,1,9334,1,7,12,1,10 };
    static oid queueChunkSize_oid[] = { 1,3,6,1,4,1,9334,1,7,13 };
    static oid queueMaxMemory_oid[] = { 1,3,6,1,4,1,9334,1,7,14 };
    static oid queueInitialNumChunks_oid[] = { 1,3,6,1,4,1,9334,1,7,15 };
    static oid protocolInfoAddr_oid[] = { 1,3,6,1,4,1,9334,1,7,16 };
    static oid protocolInfoPort_oid[] = { 1,3,6,1,4,1,9334,1,7,17 };
    static oid keepAliveInterval_oid[] = { 1,3,6,1,4,1,9334,1,7,18 };
    static oid autoconnectInterval_oid[] = { 1,3,6,1,4,1,9334,1,7,19 };
    static oid connectResponseTimeout_oid[] = { 1,3,6,1,4,1,9334,1,7,20 };
    static oid waitBestCollectorTimeout_oid[] = { 1,3,6,1,4,1,9334,1,7,21 };
    static oid dataAckTimeInterval_oid[] = { 1,3,6,1,4,1,9334,1,7,22 };
    static oid dataAckSequenceInterval_oid[] = { 1,3,6,1,4,1,9334,1,7,23 };
    static oid multiSession_oid[] = { 1,3,6,1,4,1,9334,1,7,24,1 };
    static oid templateNegotiation_oid[] = { 1,3,6,1,4,1,9334,1,7,24,2 };
    static oid structureSupport_oid[] = { 1,3,6,1,4,1,9334,1,7,24,3 };
    static oid addCollectorName_oid[] = { 1,3,6,1,4,1,9334,1,8,1,1 };
    static oid addCollectorAddress_oid[] = { 1,3,6,1,4,1,9334,1,8,1,2 };
    static oid addCollectorPort_oid[] = { 1,3,6,1,4,1,9334,1,8,1,3 };
    static oid addCollectorConnections_oid[] = { 1,3,6,1,4,1,9334,1,8,1,4 };
    static oid removeCollectorName_oid[] = { 1,3,6,1,4,1,9334,1,8,2,1 };
    static oid addSessionID_oid[] = { 1,3,6,1,4,1,9334,1,8,3,1 };
    static oid addSessionName_oid[] = { 1,3,6,1,4,1,9334,1,8,3,2 };
    static oid addSessionDescription_oid[] = { 1,3,6,1,4,1,9334,1,8,3,3 };
    static oid removeSessionID_oid[] = { 1,3,6,1,4,1,9334,1,8,4,1 };
    static oid startSessionID_oid[] = { 1,3,6,1,4,1,9334,1,8,5,1 };
    static oid startSessionNegotiate_oid[] = { 1,3,6,1,4,1,9334,1,8,5,2 };
    static oid stopSessionID_oid[] = { 1,3,6,1,4,1,9334,1,8,6,1 };
    static oid stopSessionReason_oid[] = { 1,3,6,1,4,1,9334,1,8,6,2 };
    static oid stopSessionTimeout_oid[] = { 1,3,6,1,4,1,9334,1,8,6,3 };
    static oid assignCollectorSessionID_oid[] = { 1,3,6,1,4,1,9334,1,8,7,1 };
    static oid assignCollectorName_oid[] = { 1,3,6,1,4,1,9334,1,8,7,2 };
    static oid assignCollectorPrioriry_oid[] = { 1,3,6,1,4,1,9334,1,8,7,3 };
    static oid removeCollectorSessionID_oid[] = { 1,3,6,1,4,1,9334,1,8,8,1 };
    static oid removeCollectorSessionName_oid[] = { 1,3,6,1,4,1,9334,1,8,8,2 };
	static oid reconfigureExporter_oid[] = { 1,3,6,1,4,1,9334,1,8,9,1 };
	static oid commandString_oid[] = { 1,3,6,1,4,1,9334,1,8,10,1 };
    static oid commandResultString_oid[] = { 1,3,6,1,4,1,9334,1,8,10,2 };

	DEBUGMSGTL(("exporter", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("exporterAddress", handle_exporterAddress,
                               exporterAddress_oid, OID_LENGTH(exporterAddress_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("exporterPort", handle_exporterPort,
                               exporterPort_oid, OID_LENGTH(exporterPort_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("vendorString", handle_vendorString,
                               vendorString_oid, OID_LENGTH(vendorString_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("consolePort", handle_consolePort,
                               consolePort_oid, OID_LENGTH(consolePort_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("consolePassword", handle_consolePassword,
                               consolePassword_oid, OID_LENGTH(consolePassword_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("loggerAddress", handle_loggerAddress,
                               loggerAddress_oid, OID_LENGTH(loggerAddress_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("loggerPort", handle_loggerPort,
                               loggerPort_oid, OID_LENGTH(loggerPort_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("moduleExporter", handle_moduleExporter,
                               moduleExporter_oid, OID_LENGTH(moduleExporter_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("moduleQueue", handle_moduleQueue,
                               moduleQueue_oid, OID_LENGTH(moduleQueue_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("moduleTCP", handle_moduleTCP,
                               moduleTCP_oid, OID_LENGTH(moduleTCP_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("moduleMemory", handle_moduleMemory,
                               moduleMemory_oid, OID_LENGTH(moduleMemory_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("moduleProtocol", handle_moduleProtocol,
                               moduleProtocol_oid, OID_LENGTH(moduleProtocol_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("modulePlatform", handle_modulePlatform,
                               modulePlatform_oid, OID_LENGTH(modulePlatform_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("moduleHost", handle_moduleHost,
                               moduleHost_oid, OID_LENGTH(moduleHost_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("windowSize", handle_windowSize,
                               windowSize_oid, OID_LENGTH(windowSize_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("windowTimeout", handle_windowTimeout,
                               windowTimeout_oid, OID_LENGTH(windowTimeout_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("templateAckTimeout", handle_templateAckTimeout,
                               templateAckTimeout_oid, OID_LENGTH(templateAckTimeout_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("statisticsInterval", handle_statisticsInterval,
                               statisticsInterval_oid, OID_LENGTH(statisticsInterval_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataRcvChunkSize", handle_dataRcvChunkSize,
                               dataRcvChunkSize_oid, OID_LENGTH(dataRcvChunkSize_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataRcvMaxMemory", handle_dataRcvMaxMemory,
                               dataRcvMaxMemory_oid, OID_LENGTH(dataRcvMaxMemory_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataRcvInitialNumChunks", handle_dataRcvInitialNumChunks,
                               dataRcvInitialNumChunks_oid, OID_LENGTH(dataRcvInitialNumChunks_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataSndChunkSize", handle_dataSndChunkSize,
                               dataSndChunkSize_oid, OID_LENGTH(dataSndChunkSize_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataSndMaxMemory", handle_dataSndMaxMemory,
                               dataSndMaxMemory_oid, OID_LENGTH(dataSndMaxMemory_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataSndInitialNumChunks", handle_dataSndInitialNumChunks,
                               dataSndInitialNumChunks_oid, OID_LENGTH(dataSndInitialNumChunks_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sendBuffersChunkSize", handle_sendBuffersChunkSize,
                               sendBuffersChunkSize_oid, OID_LENGTH(sendBuffersChunkSize_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sendBuffersMaxMemory", handle_sendBuffersMaxMemory,
                               sendBuffersMaxMemory_oid, OID_LENGTH(sendBuffersMaxMemory_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sendBuffersInitialNumChunks", handle_sendBuffersInitialNumChunks,
                               sendBuffersInitialNumChunks_oid, OID_LENGTH(sendBuffersInitialNumChunks_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("flushInterval", handle_flushInterval,
                               flushInterval_oid, OID_LENGTH(flushInterval_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("queueChunkSize", handle_queueChunkSize,
                               queueChunkSize_oid, OID_LENGTH(queueChunkSize_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("queueMaxMemory", handle_queueMaxMemory,
                               queueMaxMemory_oid, OID_LENGTH(queueMaxMemory_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("queueInitialNumChunks", handle_queueInitialNumChunks,
                               queueInitialNumChunks_oid, OID_LENGTH(queueInitialNumChunks_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("protocolInfoAddr", handle_protocolInfoAddr,
                               protocolInfoAddr_oid, OID_LENGTH(protocolInfoAddr_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("protocolInfoPort", handle_protocolInfoPort,
                               protocolInfoPort_oid, OID_LENGTH(protocolInfoPort_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("keepAliveInterval", handle_keepAliveInterval,
                               keepAliveInterval_oid, OID_LENGTH(keepAliveInterval_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("autoconnectInterval", handle_autoconnectInterval,
                               autoconnectInterval_oid, OID_LENGTH(autoconnectInterval_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("connectResponseTimeout", handle_connectResponseTimeout,
                               connectResponseTimeout_oid, OID_LENGTH(connectResponseTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("waitBestCollectorTimeout", handle_waitBestCollectorTimeout,
                               waitBestCollectorTimeout_oid, OID_LENGTH(waitBestCollectorTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataAckTimeInterval", handle_dataAckTimeInterval,
                               dataAckTimeInterval_oid, OID_LENGTH(dataAckTimeInterval_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dataAckSequenceInterval", handle_dataAckSequenceInterval,
                               dataAckSequenceInterval_oid, OID_LENGTH(dataAckSequenceInterval_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("multiSession", handle_multiSession,
                               multiSession_oid, OID_LENGTH(multiSession_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("templateNegotiation", handle_templateNegotiation,
                               templateNegotiation_oid, OID_LENGTH(templateNegotiation_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("structureSupport", handle_structureSupport,
                               structureSupport_oid, OID_LENGTH(structureSupport_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addCollectorName", handle_addCollectorName,
                               addCollectorName_oid, OID_LENGTH(addCollectorName_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addCollectorAddress", handle_addCollectorAddress,
                               addCollectorAddress_oid, OID_LENGTH(addCollectorAddress_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addCollectorPort", handle_addCollectorPort,
                               addCollectorPort_oid, OID_LENGTH(addCollectorPort_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addCollectorConnections", handle_addCollectorConnections,
                               addCollectorConnections_oid, OID_LENGTH(addCollectorConnections_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("removeCollectorName", handle_removeCollectorName,
                               removeCollectorName_oid, OID_LENGTH(removeCollectorName_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addSessionID", handle_addSessionID,
                               addSessionID_oid, OID_LENGTH(addSessionID_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addSessionName", handle_addSessionName,
                               addSessionName_oid, OID_LENGTH(addSessionName_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("addSessionDescription", handle_addSessionDescription,
                               addSessionDescription_oid, OID_LENGTH(addSessionDescription_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("removeSessionID", handle_removeSessionID,
                               removeSessionID_oid, OID_LENGTH(removeSessionID_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("startSessionID", handle_startSessionID,
                               startSessionID_oid, OID_LENGTH(startSessionID_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("startSessionNegotiate", handle_startSessionNegotiate,
                               startSessionNegotiate_oid, OID_LENGTH(startSessionNegotiate_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("stopSessionID", handle_stopSessionID,
                               stopSessionID_oid, OID_LENGTH(stopSessionID_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("stopSessionReason", handle_stopSessionReason,
                               stopSessionReason_oid, OID_LENGTH(stopSessionReason_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("stopSessionTimeout", handle_stopSessionTimeout,
                               stopSessionTimeout_oid, OID_LENGTH(stopSessionTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("assignCollectorSessionID", handle_assignCollectorSessionID,
                               assignCollectorSessionID_oid, OID_LENGTH(assignCollectorSessionID_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("assignCollectorName", handle_assignCollectorName,
                               assignCollectorName_oid, OID_LENGTH(assignCollectorName_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("assignCollectorPrioriry", handle_assignCollectorPrioriry,
                               assignCollectorPrioriry_oid, OID_LENGTH(assignCollectorPrioriry_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("removeCollectorSessionID", handle_removeCollectorSessionID,
                               removeCollectorSessionID_oid, OID_LENGTH(removeCollectorSessionID_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("removeCollectorSessionName", handle_removeCollectorSessionName,
                               removeCollectorSessionName_oid, OID_LENGTH(removeCollectorSessionName_oid),
                               HANDLER_CAN_RWRITE
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("reconfigureExporter", handle_reconfigureExporter,
                               reconfigureExporter_oid, OID_LENGTH(reconfigureExporter_oid),
                               HANDLER_CAN_RWRITE
		));

	    netsnmp_register_scalar(
        netsnmp_create_handler_registration("commandString", handle_commandString,
                               commandString_oid, OID_LENGTH(commandString_oid),
                               HANDLER_CAN_RWRITE
		));

	    netsnmp_register_scalar(
        netsnmp_create_handler_registration("commandResultString", handle_commandResultString,
                               commandResultString_oid, OID_LENGTH(commandResultString_oid),
                               HANDLER_CAN_RONLY
		));

	/*
	* here we initialize all the tables we're planning on supporting
	*/
	initialize_table_sessionsTable();
	initialize_table_collectorsTable();
	initialize_table_templatesTable();
	initialize_table_keysTable();
	initialize_table_keysAttributesTable();
	initialize_table_collectorsSessionsTable();
}

int
handle_exporterAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IPAddressConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_exporterAddress);
}

int
handle_exporterPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_exporterPort);
}

int
handle_vendorString(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_vendorString);
}

int
handle_consolePort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_console_consolePort);
}

int
handle_consolePassword(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_console_consolePassword);
}
int
handle_loggerAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IPAddressConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_loggerAddress);
}
int
handle_loggerPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_loggerPort);
}

int
handle_moduleExporter(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_moduleExporter);
}

int
handle_moduleQueue(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_moduleQueue);}
int
handle_moduleTCP(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_moduleTCP);
}

int
handle_moduleMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_moduleMemory);
}

int
handle_moduleProtocol(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_moduleProtocol);
}

int
handle_modulePlatform(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_modulePlatform);
}

int
handle_moduleHost(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_logging_levels_moduleHost);
}

int
handle_windowSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_windowSize);
}

int
handle_windowTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_windowTimeout);
}

int
handle_templateAckTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_templateAckTimeout);
}

int
handle_statisticsInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_statisticsInterval);
}

int
handle_dataRcvChunkSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_dataRcvChunkSize);
}

int
handle_dataRcvMaxMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_dataRcvMaxMemory);
}

int
handle_dataRcvInitialNumChunks(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_dataRcvInitialNumChunks);
}

int
handle_dataSndChunkSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_dataSndChunkSize);
}

int
handle_dataSndMaxMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_dataSndMaxMemory);
}

int
handle_dataSndInitialNumChunks(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_dataSndInitialNumChunks);
}

int
handle_sendBuffersChunkSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_sendBuffersChunkSize);
}

int
handle_sendBuffersMaxMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_sendBuffersMaxMemory);
}

int
handle_sendBuffersInitialNumChunks(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_sendBuffersInitialNumChunks);
}

int
handle_flushInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_transport_tcpTransport_flushInterval);
}

int
handle_queueChunkSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_queueChunkSize);
}

int
handle_queueMaxMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_queueMaxMemory);
}

int
handle_queueInitialNumChunks(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_queueInitialNumChunks);
}

int
handle_protocolInfoAddr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IPAddressConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_protocolInfoAddr);
}

int
handle_protocolInfoPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_protocolInfoPort);
}

int
handle_keepAliveInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_keepAliveInterval);
}

int
handle_autoconnectInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_autoconnectInterval);
}

int
handle_connectResponseTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_connectResponseTimeout);
}

int
handle_waitBestCollectorTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_waitBestCollectorTimeout);
}

int
handle_dataAckTimeInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_dataAckTimeInterval);
}

int
handle_dataAckSequenceInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_dataAckSequenceInterval);
}

int
handle_multiSession(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_capabilities_multiSession);
}

int
handle_templateNegotiation(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_capabilities_templateNegotiation);
}

int
handle_structureSupport(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerConfigHandler(	handler,
												reginfo,
												reqinfo,
												requests,
												STR_configuration_capabilities_structureSupport);
}

int
handle_addCollectorName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPaddCollector.addCollectorName,
											SNMPTryAddCollector);
}
int
handle_addCollectorAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IPAddressCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPaddCollector.addCollectorAddress),
											SNMPTryAddCollector);
}
int
handle_addCollectorPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPaddCollector.addCollectorPort),
											SNMPTryAddCollector);
}
int
handle_addCollectorConnections(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPaddCollector.addCollectorConnections),
											SNMPTryAddCollector);
}
int
handle_removeCollectorName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPremoveCollector.removeCollectorName,
											SNMPTryRemoveCollector);
}
int
handle_addSessionID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPaddSession.addSessionID),
											SNMPTryAddSession);
}
int
handle_addSessionName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPaddSession.addSessionName,
											SNMPTryAddSession);
}
int
handle_addSessionDescription(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPaddSession.addSessionDescription,
											SNMPTryAddSession);
}
int
handle_removeSessionID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPremoveSession.removeSessionID),
											SNMPTryRemoveSession);
}

int
handle_startSessionID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPstartSession.startSessionID),
											SNMPTryStartSession);
}

int
handle_startSessionNegotiate(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPstartSession.startSessionNegotiate),
											SNMPTryStartSession);
}

int
handle_stopSessionID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPstopSession.stopSessionID),
											SNMPTryStopSession);
}

int
handle_stopSessionReason(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPstopSession.stopSessionReason),
											SNMPTryStopSession);
}

int
handle_stopSessionTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPstopSession.stopSessionTimeout),
											SNMPTryStopSession);
}

int
handle_assignCollectorSessionID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPassignCollectorToSession.assignCollectorSessionID),
											SNMPTryAssignCollectorToSession);
}
int
handle_assignCollectorName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPassignCollectorToSession.assignCollectorName,
											SNMPTryAssignCollectorToSession);
}
int
handle_assignCollectorPrioriry(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPassignCollectorToSession.assignCollectorPrioriry),
											SNMPTryAssignCollectorToSession);
}
int
handle_removeCollectorSessionID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPremoveCollectorFromSession.removeCollectorSessionID),
											SNMPTryRemoveCollectorFromSession);
}
int
handle_removeCollectorSessionName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPremoveCollectorFromSession.removeCollectorSessionName,
											SNMPTryRemoveCollectorFromSession);
}

int
handle_reconfigureExporter(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__IntegerCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											&(SNMPreconfigureExporter.reconfigureExporter),
											SNMPTryReconfigureExporter);
}

int
handle_commandString(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPcommandString.string,
											SNMPTryExecCommand);
}

int
handle_commandResultString(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	return ExporterMIB__StringCommandHandler(handler,
											reginfo,
											reqinfo,
											requests,
											SNMPcommandResultString.string,
											SNMPTryExecCommand);
}

/** Initialize the sessionsTable table by defining its contents and how it's structured */
void
initialize_table_sessionsTable(void)
{
    static oid      sessionsTable_oid[] = { 1, 3, 6, 1, 4, 1, 9334, 1, 1 };
    size_t          sessionsTable_oid_len = OID_LENGTH(sessionsTable_oid);

	netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    reg =
        netsnmp_create_handler_registration("sessionsTable",
                                            sessionsTable_handler,
                                            sessionsTable_oid,
                                            sessionsTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: sessionID */
                                     0);
    table_info->min_column = sessionsTable_COL_MIN;
    table_info->max_column = sessionsTable_COL_MAX;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = sessionsTable_get_first_data_point;
    iinfo->get_next_data_point = sessionsTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

	/*reg->handler->myvoid = iinfo;*/

	netsnmp_register_table_iterator(reg, iinfo);


	/*
     * Initialise the contents of the table here
     */
}

    /*
     * Typical data structure for a row entry
     */
struct sessionsTable_entry {
    /*
     * Index values
     */
    long            sessionID;

    /*
     * Column values
     */
    char            sessionName[ASN_VAR_STR_SIZE];
    char            sessionDescription[ASN_VAR_STR_SIZE];
    u_long          sessionTransmittedRecords;
    u_long          sessionAcknowledgedRecords;
    u_long          sessionEnqueuedRecords;
    u_long          sessionLostRecords;
    u_long          sessionOutstandingRecords;
    u_long          sessionUnacknowledgedRecords;

    /*
     * Illustrate using a simple linked list
     */
    int             valid;
    struct sessionsTable_entry *next;
};

static struct sessionsTable_entry *sessionsTable_head = NULL;

/*
 * create a new row in the (unsorted) table
 */
struct sessionsTable_entry *
sessionsTable_createEntry(long sessionID,
						char *sessionName,
						char *sessionDescription,
						u_long sessionTransmittedRecords,
						u_long sessionAcknowledgedRecords,
						u_long sessionEnqueuedRecords,
						u_long sessionLostRecords,
						u_long sessionOutstandingRecords,
						u_long sessionUnacknowledgedRecords)
{
    struct sessionsTable_entry *entry;

    entry = SNMP_MALLOC_STRUCT(sessionsTable_entry);
    if (!entry)
        return NULL;

    entry->sessionID = sessionID;
    SNMP_COPY_STRING(entry->sessionName, sessionName);
    SNMP_COPY_STRING(entry->sessionDescription, sessionDescription);
    entry->sessionTransmittedRecords = sessionTransmittedRecords;
    entry->sessionAcknowledgedRecords = sessionAcknowledgedRecords;
    entry->sessionEnqueuedRecords = sessionEnqueuedRecords;
    entry->sessionLostRecords = sessionLostRecords;
    entry->sessionOutstandingRecords = sessionOutstandingRecords;
    entry->sessionUnacknowledgedRecords = sessionUnacknowledgedRecords;

	entry->next = sessionsTable_head;
    sessionsTable_head = entry;
    return entry;
}

/*
 * remove a row from the table
 */
void
sessionsTable_removeEntry(struct sessionsTable_entry *entry)
{
    struct sessionsTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = sessionsTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        sessionsTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work
 */
netsnmp_variable_list *
sessionsTable_get_first_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{
	Exporter *E = (Exporter *) ExporterMIB_MIBHandle->ExporterHandle;
	int i;

	struct sessionsTable_entry *ptr;

    for (ptr = sessionsTable_head, sessionsTable_head = NULL;
         ptr != NULL; sessionsTable_head = ptr, ptr = ptr->next) {
		if (sessionsTable_head)
        	SNMP_FREE(sessionsTable_head);
    }
	if (sessionsTable_head)
		SNMP_FREE(sessionsTable_head);


	for (i = 0; i < E->Sessions.Length; i++)
	{
		Session *S = (Session *) E->Sessions.Data[i];
		if(!S)
			continue ;

		sessionsTable_createEntry(	S->ID,
									S->Name,
									S->Description,
									S->Statistics.TransmittedRecords,
									S->Statistics.AcknowledgedRecords,
									S->Statistics.EnqueuedRecords,
									S->Statistics.LostRecords,
									EXPORTER_QHANDLER->OutstandingDataCount(E, S),
									EXPORTER_QHANDLER->UnacknowledgedDataCount(E, S));
	}

    *my_loop_context = sessionsTable_head;
    return sessionsTable_get_next_data_point(my_loop_context,
                                             my_data_context,
                                             put_index_data, mydata);
}

netsnmp_variable_list *
sessionsTable_get_next_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{
	struct sessionsTable_entry *entry =
        (struct sessionsTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
		snmp_set_var_value(idx, (char* )& entry->sessionID,
                           sizeof(entry->sessionID));
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
    } else {
        return NULL;
    }
	return put_index_data ;
}


/** handles requests for the sessionsTable table */
int
sessionsTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct sessionsTable_entry *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
			table_entry = (struct sessionsTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			if(!table_info || !table_entry)
				continue;

            switch (table_info->colnum) {
            case COLUMN_SESSIONID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char* )& table_entry->sessionID,
                                         sizeof(table_entry->sessionID));
                break;
            case COLUMN_SESSIONNAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->sessionName,
                                         strlen(table_entry->sessionName));
                break;
            case COLUMN_SESSIONDESCRIPTION:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->sessionDescription,
                                         strlen(table_entry->
                                                sessionDescription));
                break;
            case COLUMN_SESSIONTRANSMITTEDRECORDS:
                snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
                                         (char* )& table_entry->
                                         sessionTransmittedRecords,
                                         sizeof(table_entry->
                                                sessionTransmittedRecords));
                break;
            case COLUMN_SESSIONACKNOWLEDGEDRECORDS:
                snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
                                         (char* )& table_entry->
                                         sessionAcknowledgedRecords,
                                         sizeof(table_entry->
                                                sessionAcknowledgedRecords));
                break;
            case COLUMN_SESSIONENQUEUEDRECORDS:
                snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
                                         (char* )& table_entry->
                                         sessionEnqueuedRecords,
                                         sizeof(table_entry->
                                                sessionEnqueuedRecords));
                break;
            case COLUMN_SESSIONLOSTRECORDS:
                snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
                                         (char* )& table_entry->sessionLostRecords,
                                         sizeof(table_entry->
                                                sessionLostRecords));
                break;
            case COLUMN_SESSIONOUTSTANDINGRECORDS:
                snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
                                         (char* )& table_entry->
                                         sessionOutstandingRecords,
                                         sizeof(table_entry->
                                                sessionOutstandingRecords));
                break;
            case COLUMN_SESSIONUNACKNOWLEDGEDRECORDS:
                snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
                                         (char* )& table_entry->
                                         sessionUnacknowledgedRecords,
                                         sizeof(table_entry->
                                                sessionUnacknowledgedRecords));
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the collectorsTable table by defining its contents and how it's structured */
void
initialize_table_collectorsTable(void)
{
    static oid      collectorsTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 9334, 1, 2 };
    size_t          collectorsTable_oid_len =
        OID_LENGTH(collectorsTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    reg =
        netsnmp_create_handler_registration("collectorsTable",
                                            collectorsTable_handler,
                                            collectorsTable_oid,
                                            collectorsTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_IPADDRESS, /* index: collectorAddress */
                                     ASN_INTEGER,       /* index: collectorPort */
                                     0);
    table_info->min_column = collectorsTable_COL_MIN;
    table_info->max_column = collectorsTable_COL_MAX;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = collectorsTable_get_first_data_point;
    iinfo->get_next_data_point = collectorsTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here
     */
}

    /*
     * Typical data structure for a row entry
     */
struct collectorsTable_entry {
    /*
     * Index values
     */
    u_long          collectorAddress;
    long            collectorPort;

    /*
     * Column values
     */
    long            collectorConnections;
    char            collectorName[ASN_VAR_STR_SIZE];

    /*
     * Illustrate using a simple linked list
     */
    int             valid;
    struct collectorsTable_entry *next;
};

static struct collectorsTable_entry *collectorsTable_head = NULL;

/*
 * create a new row in the (unsorted) table
 */
struct collectorsTable_entry *
collectorsTable_createEntry(u_long collectorAddress,
							long collectorPort,
							long collectorConnections,
							char* collectorName)
{
    struct collectorsTable_entry *entry;

    entry = SNMP_MALLOC_STRUCT(collectorsTable_entry);
    if (!entry)
        return NULL;

    entry->collectorAddress = collectorAddress;
    entry->collectorPort = collectorPort;
	entry->collectorConnections = collectorConnections;
	SNMP_COPY_STRING(entry->collectorName, collectorName);

    entry->next = collectorsTable_head;
    collectorsTable_head = entry;
    return entry;
}

/*
 * remove a row from the table
 */
void
collectorsTable_removeEntry(struct collectorsTable_entry *entry)
{
    struct collectorsTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = collectorsTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        collectorsTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work
 */
netsnmp_variable_list *
collectorsTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
	Exporter *E = (Exporter *) ExporterMIB_MIBHandle->ExporterHandle;
	int i;

	struct collectorsTable_entry *ptr;

    for (ptr = collectorsTable_head, collectorsTable_head = NULL;
         ptr != NULL; collectorsTable_head = ptr, ptr = ptr->next) {
		if (collectorsTable_head)
        	SNMP_FREE(collectorsTable_head);
    }
	if (collectorsTable_head)
		SNMP_FREE(collectorsTable_head);

	for (i = 0; i < E->Collectors.Length; i++)
	{
		Collector *C = (Collector *) E->Collectors.Data[i];
		if(!C)
			continue ;

		collectorsTable_createEntry(C->Addr,
									C->Port,
									C->NumOfConnections,
									C->Name);

	}

    *my_loop_context = collectorsTable_head;
    return collectorsTable_get_next_data_point(my_loop_context,
                                               my_data_context,
                                               put_index_data, mydata);
}

netsnmp_variable_list *
collectorsTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
    struct collectorsTable_entry *entry =
        (struct collectorsTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_value(idx, (char *)& entry->collectorAddress,
                           sizeof(entry->collectorAddress));
        idx = idx->next_variable;
        snmp_set_var_value(idx, (char *)& entry->collectorPort,
                           sizeof(entry->collectorPort));
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
    } else {
        return NULL;
    }
	return put_index_data ;
}


/** handles requests for the collectorsTable table */
int
collectorsTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct collectorsTable_entry *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct collectorsTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			if(! table_entry || ! table_info)
				continue ;

            switch (table_info->colnum) {
            case COLUMN_COLLECTORADDRESS:
				{
					u_long addr = htonl(table_entry->collectorAddress);
					snmp_set_var_typed_value(request->requestvb, ASN_IPADDRESS,
											(char *)&addr,
											sizeof(table_entry->
													collectorAddress));
				}
                break;
            case COLUMN_COLLECTORPORT:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->collectorPort,
                                         sizeof(table_entry->
                                                collectorPort));
                break;
            case COLUMN_COLLECTORCONNECTIONS:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->collectorConnections,
                                         sizeof(table_entry->
                                                collectorConnections));
                break;
            case COLUMN_COLLECTORNAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->collectorName,
                                         strlen(table_entry->
                                                collectorName));
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the templatesTable table by defining its contents and how it's structured */
void
initialize_table_templatesTable(void)
{
    static oid      templatesTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 9334, 1, 3 };
    size_t          templatesTable_oid_len =
        OID_LENGTH(templatesTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    reg =
        netsnmp_create_handler_registration("templatesTable",
                                            templatesTable_handler,
                                            templatesTable_oid,
                                            templatesTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: templateID */
                                     0);
    table_info->min_column = templatesTable_COL_MIN;
    table_info->max_column = templatesTable_COL_MAX;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = templatesTable_get_first_data_point;
    iinfo->get_next_data_point = templatesTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here
     */
}

    /*
     * Typical data structure for a row entry
     */
struct templatesTable_entry {
    /*
     * Index values
     */
    long            templateSessionID;
    long            templateID;

    /*
     * Column values
     */
    char            templateSchemaName[ASN_VAR_STR_SIZE];
    char            templateTypeName[ASN_VAR_STR_SIZE];
    char            templateDescription[ASN_VAR_STR_SIZE];
    long            templateNumKeys;

    /*
     * Illustrate using a simple linked list
     */
    int             valid;
    struct templatesTable_entry *next;
};

static struct templatesTable_entry *templatesTable_head = NULL;

/*
 * create a new row in the (unsorted) table
 */
struct templatesTable_entry *
templatesTable_createEntry(	long templateSessionID,
							long templateID,
							char *templateSchemaName,
							char *templateTypeName,
							char *templateDescription,
							long templateNumKeys)
{
    struct templatesTable_entry *entry;

    entry = SNMP_MALLOC_STRUCT(templatesTable_entry);
    if (!entry)
        return NULL;

	entry->templateSessionID = templateSessionID;
    entry->templateID = templateID;
	SNMP_COPY_STRING(entry->templateSchemaName, templateSchemaName);
	SNMP_COPY_STRING(entry->templateTypeName, templateTypeName);
	SNMP_COPY_STRING(entry->templateDescription, templateDescription);
	entry->templateNumKeys = templateNumKeys ;

    entry->next = templatesTable_head;
    templatesTable_head = entry;
    return entry;
}

/*
 * remove a row from the table
 */
void
templatesTable_removeEntry(struct templatesTable_entry *entry)
{
    struct templatesTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = templatesTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        templatesTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work
 */
netsnmp_variable_list *
templatesTable_get_first_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
	Exporter *E = (Exporter *) ExporterMIB_MIBHandle->ExporterHandle;
	int i, j;

	struct templatesTable_entry *ptr;

    for (ptr = templatesTable_head, templatesTable_head = NULL;
         ptr != NULL; templatesTable_head = ptr, ptr = ptr->next) {
		if (templatesTable_head)
        	SNMP_FREE(templatesTable_head);
    }
	if (templatesTable_head)
		SNMP_FREE(templatesTable_head);

	for (i = 0; i < E->Sessions.Length; i++)
	{
		TransmissionContext *TC = NULL;
		DynamicArray *Tmpls = NULL;
		Session *S = (Session *) E->Sessions.Data[i];
		if(!S)
			continue ;

		TC = S->ActiveContext;
		if(!TC)
			continue ;

		Tmpls = & (TC->Templates);
		if(!Tmpls)
			continue ;

		for (j = 0; j < Tmpls->Length; j++)
		{
        	Template *Tmpl = (Template *) Tmpls->Data[j];
        	if (Tmpl == NULL)
            	continue;

			templatesTable_createEntry(	S->ID,
										Tmpl->TemplateID,
										Tmpl->SchemaName,
										Tmpl->TypeName,
										NULL,
										Tmpl->Keys.Length);
		}
	}

    *my_loop_context = templatesTable_head;
    return templatesTable_get_next_data_point(my_loop_context,
                                              my_data_context,
                                              put_index_data, mydata);
}

netsnmp_variable_list *
templatesTable_get_next_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{
    struct templatesTable_entry *entry =
        (struct templatesTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_value(idx, (char *)& entry->templateID,
                           sizeof(entry->templateID));
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
    } else {
        return NULL;
    }
	return put_index_data ;
}


/** handles requests for the templatesTable table */
int
templatesTable_handler(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct templatesTable_entry *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct templatesTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			if(! table_entry || ! table_info)
				continue;

			switch (table_info->colnum) {
            case COLUMN_TEMPLATESESSIONID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->templateSessionID,
                                         sizeof(table_entry->
                                                templateSessionID));
                break;
            case COLUMN_TEMPLATEID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->templateID,
                                         sizeof(table_entry->templateID));
                break;
            case COLUMN_TEMPLATESCHEMANAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->templateSchemaName,
                                         strlen(table_entry->
                                                templateSchemaName));
                break;
            case COLUMN_TEMPLATETYPENAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->templateTypeName,
                                         strlen(table_entry->
                                                templateTypeName));
                break;
            case COLUMN_TEMPLATEDESCRIPTION:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->templateDescription,
                                         strlen(table_entry->
                                                templateDescription));
                break;
            case COLUMN_TEMPLATENUMKEYS:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->templateNumKeys,
                                         sizeof(table_entry->
                                                templateNumKeys));
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the keysTable table by defining its contents and how it's structured */
void
initialize_table_keysTable(void)
{
    static oid      keysTable_oid[] = { 1, 3, 6, 1, 4, 1, 9334, 1, 4 };
    size_t          keysTable_oid_len = OID_LENGTH(keysTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    reg =
        netsnmp_create_handler_registration("keysTable", keysTable_handler,
                                            keysTable_oid,
                                            keysTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: keySessionID */
                                     ASN_INTEGER,       /* index: keyTemplateID */
                                     ASN_INTEGER,       /* index: keyID */
                                     0);
    table_info->min_column = keysTable_COL_MIN;
    table_info->max_column = keysTable_COL_MAX;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = keysTable_get_first_data_point;
    iinfo->get_next_data_point = keysTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here
     */
}

    /*
     * Typical data structure for a row entry
     */
struct keysTable_entry {
    /*
     * Index values
     */
    long            keySessionID;
    long            keyTemplateID;
    long            keyID;

    /*
     * Column values
     */
    long            keyTypeID;
    char            keyName[ASN_VAR_STR_SIZE];
    char            keyLabel[ASN_VAR_STR_SIZE];
    char            keyHelp[ASN_VAR_STR_SIZE];
    long            keyEnabled;

    /*
     * Illustrate using a simple linked list
     */
    int             valid;
    struct keysTable_entry *next;
};

static struct keysTable_entry *keysTable_head = NULL;

/*
 * create a new row in the (unsorted) table
 */
struct keysTable_entry *
keysTable_createEntry(	long keySessionID,
						long keyTemplateID,
						long keyID,
						long keyTypeID,
						char *keyName,
						char *keyLabel,
						char *keyHelp,
						long keyEnabled)
{
    struct keysTable_entry *entry;

    entry = SNMP_MALLOC_STRUCT(keysTable_entry);
    if (!entry)
        return NULL;

    entry->keySessionID = keySessionID;
    entry->keyTemplateID = keyTemplateID;
    entry->keyID = keyID;
	entry->keyTypeID = keyTypeID;
	SNMP_COPY_STRING(entry->keyName, keyName);
	SNMP_COPY_STRING(entry->keyLabel, keyLabel);
	SNMP_COPY_STRING(entry->keyHelp, keyHelp);
	entry->keyEnabled = keyEnabled ;

    entry->next = keysTable_head;
    keysTable_head = entry;
    return entry;
}

/*
 * remove a row from the table
 */
void
keysTable_removeEntry(struct keysTable_entry *entry)
{
    struct keysTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = keysTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        keysTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work
 */
netsnmp_variable_list *
keysTable_get_first_data_point(void **my_loop_context,
                               void **my_data_context,
                               netsnmp_variable_list * put_index_data,
                               netsnmp_iterator_info *mydata)
{
	Exporter *E = (Exporter *) ExporterMIB_MIBHandle->ExporterHandle;
	int i, j, k;

	struct keysTable_entry *ptr;

    for (ptr = keysTable_head, keysTable_head = NULL;
         ptr != NULL; keysTable_head = ptr, ptr = ptr->next) {
		if (keysTable_head)
        	SNMP_FREE(keysTable_head);
    }
	if (keysTable_head)
		SNMP_FREE(keysTable_head);

	for (i = 0; i < E->Sessions.Length; i++)
	{
		TransmissionContext *TC = NULL;
		DynamicArray *Tmpls = NULL;
		Session *S = (Session *) E->Sessions.Data[i];
		if(!S)
			continue ;

		TC = S->ActiveContext;
		if(!TC)
			continue ;

		Tmpls = & (TC->Templates);
		if(!Tmpls)
			continue ;

		for (j = 0; j < Tmpls->Length; j++)
		{
        	Template *Tmpl = (Template *) Tmpls->Data[j];
        	if (Tmpl == NULL)
            	continue;

			for (k = 0; k < Tmpl->Keys.Length; k++)
			{
				Key *K = (Key *) Tmpl->Keys.Data[k];
				if(!K)
					continue ;

				keysTable_createEntry(	S->ID,
										Tmpl->TemplateID,
										K->KeyID,
										K->KeyTypeID,
										K->Name,
										K->Label,
										K->Help,
										K->Enabled);
			}
		}
	}

    *my_loop_context = keysTable_head;
    return keysTable_get_next_data_point(my_loop_context, my_data_context,
                                         put_index_data, mydata);
}

netsnmp_variable_list *
keysTable_get_next_data_point(void **my_loop_context,
                              void **my_data_context,
                              netsnmp_variable_list * put_index_data,
                              netsnmp_iterator_info *mydata)
{
    struct keysTable_entry *entry =
        (struct keysTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_value(idx, (char *)& entry->keySessionID,
                           sizeof(entry->keySessionID));
        idx = idx->next_variable;
        snmp_set_var_value(idx, (char *)& entry->keyTemplateID,
                           sizeof(entry->keyTemplateID));
        idx = idx->next_variable;
        snmp_set_var_value(idx, (char *)& entry->keyID,
						   sizeof(entry->keyID));
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
    } else {
        return NULL;
    }
	return put_index_data ;
}


/** handles requests for the keysTable table */
int
keysTable_handler(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct keysTable_entry *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct keysTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			if(! table_entry || ! table_info)
				continue;

            switch (table_info->colnum) {
            case COLUMN_KEYSESSIONID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keySessionID,
                                         sizeof(table_entry->
                                                keySessionID));
                break;
            case COLUMN_KEYTEMPLATEID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyTemplateID,
                                         sizeof(table_entry->
                                                keyTemplateID));
                break;
            case COLUMN_KEYID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyID,
                                         sizeof(table_entry->keyID));
                break;
            case COLUMN_KEYTYPEID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyTypeID,
                                         sizeof(table_entry->keyTypeID));
                break;
            case COLUMN_KEYNAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->keyName,
                                         strlen(table_entry->keyName));
                break;
            case COLUMN_KEYLABEL:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->keyLabel,
                                         strlen(table_entry->keyLabel));
                break;
            case COLUMN_KEYHELP:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->keyHelp,
                                         strlen(table_entry->keyHelp));
                break;
            case COLUMN_KEYENABLED:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyEnabled,
                                         sizeof(table_entry->keyEnabled));
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the keysAttributesTable table by defining its contents and how it's structured */
void
initialize_table_keysAttributesTable(void)
{
    static oid      keysAttributesTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 9334, 1, 5 };
    size_t          keysAttributesTable_oid_len =
        OID_LENGTH(keysAttributesTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    reg =
        netsnmp_create_handler_registration("keysAttributesTable",
                                            keysAttributesTable_handler,
                                            keysAttributesTable_oid,
                                            keysAttributesTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: keyAttributesSessionID */
                                     ASN_INTEGER,       /* index: keyAttributesTemplateID */
                                     ASN_INTEGER,       /* index: keyAttributesID */
                                     0);
    table_info->min_column = keysAttributesTable_COL_MIN;
    table_info->max_column = keysAttributesTable_COL_MAX;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = keysAttributesTable_get_first_data_point;
    iinfo->get_next_data_point = keysAttributesTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here
     */
}

    /*
     * Typical data structure for a row entry
     */
struct keysAttributesTable_entry {
    /*
     * Index values
     */
    long            keyAttributesSessionID;
    long            keyAttributesTemplateID;
    long            keyAttributesID;

    /*
     * Column values
     */
    long            keyAttributesTypeID;
    char            keyAttributesName[ASN_VAR_STR_SIZE];
    char            keyAttributesLabel[ASN_VAR_STR_SIZE];
    char            keyAttributesHelp[ASN_VAR_STR_SIZE];
    long            keyAttributesEnabled;

    /*
     * Illustrate using a simple linked list
     */
    int             valid;
    struct keysAttributesTable_entry *next;
};

static struct keysAttributesTable_entry *keysAttributesTable_head = NULL;

/*
 * create a new row in the (unsorted) table
 */
struct keysAttributesTable_entry *
keysAttributesTable_createEntry(long keyAttributesSessionID,
                                long keyAttributesTemplateID,
                                long keyAttributesID,
								long keyAttributesTypeID,
								char *keyAttributesName,
								char *keyAttributesLabel,
								char *keyAttributesHelp,
								long keyAttributesEnabled)
{
    struct keysAttributesTable_entry *entry;

    entry = SNMP_MALLOC_STRUCT(keysAttributesTable_entry);
    if (!entry)
        return NULL;

    entry->keyAttributesSessionID = keyAttributesSessionID;
    entry->keyAttributesTemplateID = keyAttributesTemplateID;
    entry->keyAttributesID = keyAttributesID;
	entry->keyAttributesTypeID = keyAttributesTypeID;
	SNMP_COPY_STRING(entry->keyAttributesName, keyAttributesName);
	SNMP_COPY_STRING(entry->keyAttributesLabel, keyAttributesLabel);
	SNMP_COPY_STRING(entry->keyAttributesHelp, keyAttributesHelp);
	entry->keyAttributesEnabled = keyAttributesEnabled ;

    entry->next = keysAttributesTable_head;
    keysAttributesTable_head = entry;
    return entry;
}

/*
 * remove a row from the table
 */
void
keysAttributesTable_removeEntry(struct keysAttributesTable_entry *entry)
{
    struct keysAttributesTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = keysAttributesTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        keysAttributesTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work
 */
netsnmp_variable_list *
keysAttributesTable_get_first_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{
	Exporter *E = (Exporter *) ExporterMIB_MIBHandle->ExporterHandle;
	int i, j, k;

	struct keysAttributesTable_entry *ptr;

    for (ptr = keysAttributesTable_head, keysAttributesTable_head = NULL;
         ptr != NULL; keysAttributesTable_head = ptr, ptr = ptr->next) {
		if (keysAttributesTable_head)
        	SNMP_FREE(keysAttributesTable_head);
    }
	if (keysAttributesTable_head)
		SNMP_FREE(keysAttributesTable_head);

	for (i = 0; i < E->Sessions.Length; i++)
	{
		TransmissionContext *TC = NULL;
		DynamicArray *Tmpls = NULL;
		Session *S = (Session *) E->Sessions.Data[i];
		if(!S)
			continue ;

		TC = S->ActiveContext;
		if(!TC)
			continue ;

		Tmpls = & (TC->Templates);
		if(!Tmpls)
			continue ;

		for (j = 0; j < Tmpls->Length; j++)
		{
        	Template *Tmpl = (Template *) Tmpls->Data[j];
        	if (Tmpl == NULL)
            	continue;

			for (k = 0; k < Tmpl->Keys.Length; k++)
			{
				Key *K = (Key *) Tmpl->Keys.Data[k];
				if(!K)
					continue ;

				keysAttributesTable_createEntry(	S->ID,
													Tmpl->TemplateID,
													K->KeyID,
													K->KeyTypeID,
													K->Name,
													K->Label,
													K->Help,
													K->Enabled);
			}
		}
	}

	*my_loop_context = keysAttributesTable_head;
    return keysAttributesTable_get_next_data_point(my_loop_context,
                                                   my_data_context,
                                                   put_index_data, mydata);
}

netsnmp_variable_list *
keysAttributesTable_get_next_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{
    struct keysAttributesTable_entry *entry =
        (struct keysAttributesTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_value(idx, (char *)& entry->keyAttributesSessionID,
                           sizeof(entry->keyAttributesSessionID));
        idx = idx->next_variable;
        snmp_set_var_value(idx, (char *)& entry->keyAttributesTemplateID,
                           sizeof(entry->keyAttributesTemplateID));
        idx = idx->next_variable;
        snmp_set_var_value(idx, (char *)& entry->keyAttributesID,
                           sizeof(entry->keyAttributesID));
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
    } else {
        return NULL;
    }
	return put_index_data ;
}


/** handles requests for the keysAttributesTable table */
int
keysAttributesTable_handler(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct keysAttributesTable_entry *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct keysAttributesTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			if(! table_entry || ! table_info)
				continue;

            switch (table_info->colnum) {
            case COLUMN_KEYATTRIBUTESSESSIONID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->
                                         keyAttributesSessionID,
                                         sizeof(table_entry->
                                                keyAttributesSessionID));
                break;
            case COLUMN_KEYATTRIBUTESTEMPLATEID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->
                                         keyAttributesTemplateID,
                                         sizeof(table_entry->
                                                keyAttributesTemplateID));
                break;
            case COLUMN_KEYATTRIBUTESID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyAttributesID,
                                         sizeof(table_entry->
                                                keyAttributesID));
                break;
            case COLUMN_KEYATTRIBUTESTYPEID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyAttributesTypeID,
                                         sizeof(table_entry->
                                                keyAttributesTypeID));
                break;
            case COLUMN_KEYATTRIBUTESNAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->keyAttributesName,
                                         strlen(table_entry->
                                                keyAttributesName));
                break;
            case COLUMN_KEYATTRIBUTESLABEL:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->keyAttributesLabel,
                                         strlen(table_entry->
                                                keyAttributesLabel));
                break;
            case COLUMN_KEYATTRIBUTESHELP:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->keyAttributesHelp,
                                         strlen(table_entry->
                                                keyAttributesHelp));
                break;
            case COLUMN_KEYATTRIBUTESENABLED:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->keyAttributesEnabled,
                                         sizeof(table_entry->
                                                keyAttributesEnabled));
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the collectorsSessionsTable table by defining its contents and how it's structured */
void
initialize_table_collectorsSessionsTable(void)
{
    static oid      collectorsSessionsTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 9334, 1, 6 };
    size_t          collectorsSessionsTable_oid_len =
        OID_LENGTH(collectorsSessionsTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    reg =
        netsnmp_create_handler_registration("collectorsSessionsTable",
                                            collectorsSessionsTable_handler,
                                            collectorsSessionsTable_oid,
                                            collectorsSessionsTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: sessionID */
                                     /*ASN_OCTET_STR,*/     /* index: collectorName */
                                     0);
    table_info->min_column = collectorsSessionsTable_COL_MIN;
    table_info->max_column = collectorsSessionsTable_COL_MAX;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        collectorsSessionsTable_get_first_data_point;
    iinfo->get_next_data_point =
        collectorsSessionsTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here
     */
}

    /*
     * Typical data structure for a row entry
     */
struct collectorsSessionsTable_entry {
    /*
     * Index values
     */
    long            collectorSssionID;
    char            collectorSssionName[ASN_VAR_STR_SIZE];

    /*
     * Column values
     */
    long            collectorSssionPriority;

    /*
     * Illustrate using a simple linked list
     */
    int             valid;
    struct collectorsSessionsTable_entry *next;
};

static struct collectorsSessionsTable_entry *collectorsSessionsTable_head = NULL;

/*
 * create a new row in the (unsorted) table
 */
struct collectorsSessionsTable_entry *
collectorsSessionsTable_createEntry(long collectorSssionID,
									char *collectorSssionName,
									long collectorSssionPriority)
{
    struct collectorsSessionsTable_entry *entry;

    entry = SNMP_MALLOC_STRUCT(collectorsSessionsTable_entry);
    if (!entry)
        return NULL;

    entry->collectorSssionID = collectorSssionID;
    SNMP_COPY_STRING(entry->collectorSssionName, collectorSssionName);
	entry->collectorSssionPriority = collectorSssionPriority;

    entry->next = collectorsSessionsTable_head;
    collectorsSessionsTable_head = entry;
    return entry;
}

/*
 * remove a row from the table
 */
void
collectorsSessionsTable_removeEntry(struct collectorsSessionsTable_entry
                                    *entry)
{
    struct collectorsSessionsTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = collectorsSessionsTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        collectorsSessionsTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/*
 * Example iterator hook routines - using 'get_next' to do most of the work
 */
netsnmp_variable_list *
collectorsSessionsTable_get_first_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
	Exporter *E = (Exporter *) ExporterMIB_MIBHandle->ExporterHandle;
	int i;

	struct collectorsSessionsTable_entry *ptr;

    for (ptr = collectorsSessionsTable_head, collectorsSessionsTable_head = NULL;
         ptr != NULL; collectorsSessionsTable_head = ptr, ptr = ptr->next) {
		if (collectorsSessionsTable_head)
        	SNMP_FREE(collectorsSessionsTable_head);
    }
	if (collectorsSessionsTable_head)
		SNMP_FREE(collectorsSessionsTable_head);

	for (i = 0; i < E->CollectorSessions.Length; i++)
	{
		CollectorSession *CS = (CollectorSession *)E->CollectorSessions.Data[i];
		if(!CS)
			continue ;

		collectorsSessionsTable_createEntry(CS->SessionPtr->ID,
											CS->Collector->Name,
											CS->Priority);
	}

    *my_loop_context = collectorsSessionsTable_head;
    return collectorsSessionsTable_get_next_data_point(my_loop_context,
                                                       my_data_context,
                                                       put_index_data,
                                                       mydata);
}

netsnmp_variable_list *
collectorsSessionsTable_get_next_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
    struct collectorsSessionsTable_entry *entry =
        (struct collectorsSessionsTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_value(idx, (char *)& entry->collectorSssionID,
                           sizeof(entry->collectorSssionID));
        idx = idx->next_variable;
        /*snmp_set_var_value(idx, entry->collectorSssionName,
                           strlen(entry->collectorSssionName));
        idx = idx->next_variable;*/
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
    } else {
        return NULL;
    }
	return put_index_data ;
}


/** handles requests for the collectorsSessionsTable table */
int
collectorsSessionsTable_handler(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct collectorsSessionsTable_entry *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct collectorsSessionsTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

			if(! table_entry || ! table_info)
				continue;

            switch (table_info->colnum) {
            case COLUMN_COLLECTORSSSIONID:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->collectorSssionID,
                                         sizeof(table_entry->
                                                collectorSssionID));
                break;
            case COLUMN_COLLECTORSSSIONNAME:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->collectorSssionName,
                                         strlen(table_entry->
                                                collectorSssionName));
                break;
            case COLUMN_COLLECTORSSSIONPRIORITY:
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                         (char *)& table_entry->
                                         collectorSssionPriority,
                                         sizeof(table_entry->
                                                collectorSssionPriority));
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}


#endif					/* SNMP_SUPPORT */
