<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Templates and keys</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Templates and keys</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__key__type__attributes.html">Key and type (template) attributes</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga0">IPDR_TemplateChangedCallback</a> )(<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r___template.html">IPDR_Template</a> *T, int NumTemplates, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga1">IPDR_NewConfigurationIDCallback</a> )(unsigned char SessionID, unsigned short *NewConfigurationID, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga2">IPDR_ConfigurationIDChangedCallback</a> )(unsigned char SessionID, unsigned short NewConfigurationID, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga3">IPDR_StartNegotiationCallback</a> )(<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___collector.html">IPDR_CollectorHandle</a> CollectorHandle, IPDR_BOOL *Negotiate, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga4">IPDR_FlowStartCallback</a> )(<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___collector.html">IPDR_CollectorHandle</a> CollectorHandle, IPDR_BOOL *ChooseThisOne, void *Arg)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, int TemplateID, const char *SchemaName, const char *TypeName, int NumKeys, const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *Keys, <a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> *TH)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga6">IPDR_CreateTemplate_All</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, int TemplateID, const char *SchemaName, const char *TypeName, int NumKeys, const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *Keys)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga7">IPDR_GetTemplate</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, int TemplateID, char **SchemaName, char **TypeName, int *NumKeys, <a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> *TH)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga8">IPDR_DeleteTemplate</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> TH)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga9">IPDR_DeleteTemplate_All</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, int TemplateID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga10">IPDR_AddKey</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> TH, const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *CKey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga11">IPDR_AddKey_All</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, int TemplateID, const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *CKey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga12">IPDR_RemoveKey</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> TH, unsigned int KeyID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga13">IPDR_RemoveKey_All</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, int TemplateID, unsigned int KeyID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga14">IPDR_EnableKey</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> TH, unsigned int KeyID, IPDR_BOOL Enabled)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga15">IPDR_EnableKey_All</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, int TemplateID, unsigned int KeyID, IPDR_BOOL Enabled)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates</a> (<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga17">IPDR_ApplyTemplates_All</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga18">IPDR_SetTemplateChangedCallback</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="group___i_p_d_r__templates.html#ga0">IPDR_TemplateChangedCallback</a> Callback, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga19">IPDR_SetNewConfigurationIDCallback</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="group___i_p_d_r__templates.html#ga1">IPDR_NewConfigurationIDCallback</a> Callback, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga20">IPDR_SetConfigurationIDChangedCallback</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="group___i_p_d_r__templates.html#ga2">IPDR_ConfigurationIDChangedCallback</a> Callback, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga21">IPDR_SetStartNegotiationCallback</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="group___i_p_d_r__templates.html#ga3">IPDR_StartNegotiationCallback</a> Callback, void *Arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">IPDR_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_d_r__templates.html#ga22">IPDR_SetFlowStartCallback</a> (<a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a> ExporterHandle, <a class="el" href="group___i_p_d_r__templates.html#ga4">IPDR_FlowStartCallback</a> Callback, void *Arg)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A host application can format data for transmission with a set of templates. Templates contain keys that can be dynamically enabled or disabled. They are a shared resource available to all sessions; the host application can define multiple templates to meet various BSS/OSS needs, and use them concurrently. At the start of a session, the IPDR collector and transmitter 'negotiate' the data to be sent. The aim is to arrive at a 'best fit' between data the platform can make available and the requirements of the business/support application(s) being used in a network.<p>
Thus, the IPDR collector indicates which of the available templates are required and which keys within them are to be enabled or disabled. This can be done strictly with the XML configuraiton, or by some interaction by querying from the collector to the transmitter and then using a GUI to select which fields are actually wanted. The transmitter, based on the configuration information received from the collector, sends the collector an indication of the data formats (templates) it will use and after the collector confirms, sends only 'raw' data. The collector interprets this compact data using the templates it has agreed with the transmitter.<p>
The host application uses the <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a> function to populate data records in accordance with the template structures. The exporter filters out disabled keys and sends the record in the context of the appropriate sessions. The exporter code is free to reorder the fields in the template to something different from the ordering within the host application's records. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga2" doxytag="IPDR.h::IPDR_ConfigurationIDChangedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__templates.html#ga2">IPDR_ConfigurationIDChangedCallback</a>)(unsigned char SessionID, unsigned short NewConfigurationID, void *Arg)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionID</em>&nbsp;</td><td>Session ID where we configuration ID has been changed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewConfigurationID</em>&nbsp;</td><td>poiner to new Configuration ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>The <em>Arg</em> parameter set by <a class="el" href="group___i_p_d_r__templates.html#ga20">IPDR_SetConfigurationIDChangedCallback()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga20">IPDR_SetConfigurationIDChangedCallback</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="IPDR.h::IPDR_FlowStartCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__templates.html#ga4">IPDR_FlowStartCallback</a>)(<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___collector.html">IPDR_CollectorHandle</a> CollectorHandle, IPDR_BOOL *ChooseThisOne, void *Arg)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback for when flow start message is received at the session This callback allows to the host application to force choice of specific Collector The flag defaults to the value, specified at capabilities <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session where the template has been changed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CollectorHanlde</em>&nbsp;</td><td>Handle to Collector which sent the message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChooseThisOne</em>&nbsp;</td><td>the output boolean value. Allows to force choosing this collector for active session at "TEMPLATE DATA" message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>The <em>Arg</em> parameter set by <a class="el" href="group___i_p_d_r__templates.html#ga22">IPDR_SetFlowStartCallback()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga22">IPDR_SetFlowStartCallback</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="IPDR.h::IPDR_NewConfigurationIDCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__templates.html#ga1">IPDR_NewConfigurationIDCallback</a>)(unsigned char SessionID, unsigned short *NewConfigurationID, void *Arg)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionID</em>&nbsp;</td><td>Session ID where we want to get new configuration ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewConfigurationID</em>&nbsp;</td><td>poiner to new Configuration ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>The <em>Arg</em> parameter set by <a class="el" href="group___i_p_d_r__templates.html#ga19">IPDR_SetNewConfigurationIDCallback()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga19">IPDR_SetNewConfigurationIDCallback</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="IPDR.h::IPDR_StartNegotiationCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__templates.html#ga3">IPDR_StartNegotiationCallback</a>)(<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r__tag___collector.html">IPDR_CollectorHandle</a> CollectorHandle, IPDR_BOOL *Negotiate, void *Arg)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback for when start negotiation message is received at the session This callback allows to the host application to decide if it willing to perform negotiation at this time <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session where the template has been changed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CollectorHanlde</em>&nbsp;</td><td>Handle to Collector which sent the message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Negotiate</em>&nbsp;</td><td>the output boolean value. If set to false, the negotiation will be rejected </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>The <em>Arg</em> parameter set by <a class="el" href="group___i_p_d_r__templates.html#ga21">IPDR_SetStartNegotiationCallback()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga21">IPDR_SetStartNegotiationCallback</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="IPDR.h::IPDR_TemplateChangedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="group___i_p_d_r__templates.html#ga0">IPDR_TemplateChangedCallback</a>)(<a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a> SessionHandle, <a class="el" href="struct_i_p_d_r___template.html">IPDR_Template</a> *T, int NumTemplates, void *Arg)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback for when a template is changed by the collector. During the template negotiation, the collector can request that certain fields be not transmitted. The IPDR exporter software will agree to this and not transmit these fields; this callback is called to inform the host application that certain fields are not needed (possibly improving its performance). The unneeded fields can safely be left unitialized when a call to <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a> is done.<p>
The host application will have an option to change the modified fields back if necessary, as demonstrated below<p>
There is no record of before/after for fields; processing should be something like this: <div class="fragment"><pre class="fragment"> *     for (i = 0; i &lt; NumTemplates; i++) {
 *       const IPDR_Template *T = Templates[i];
 *       for (j = 0; j &lt; T-&gt;NumKeys; j++) {
 *         const IPDR_Key *K = T-&gt;Keys[j];
 *         if (K-&gt;Enabled = true;
 *       }
 *     }
 *  </pre></div><p>
Or - for debugging purposes <div class="fragment"><pre class="fragment"> *     for (i = 0; i &lt; NumTemplates; i++) {
 *       const IPDR_Template *T = Templates[i];
 *       for (j = 0; j &lt; T-&gt;NumKeys; j++) {
 *         const IPDR_Key *K = T-&gt;Keys[j];
 *		   if( j % 2 )	K-&gt;Enabled = true;
 *			else K-&gt;Enabled = false;
 *       }
 *     }
 *  </pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session where the template has been changed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumTemplates</em>&nbsp;</td><td>The number of templates that have been changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Templates</em>&nbsp;</td><td>The templates that have changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>The <em>Arg</em> parameter set by <a class="el" href="group___i_p_d_r__templates.html#ga18">IPDR_SetTemplateChangedCallback()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga18">IPDR_SetTemplateChangedCallback</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga10" doxytag="IPDR.h::IPDR_AddKey"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_AddKey           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TH</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>CKey</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a key to a previously created template.<p>
If this function is called after the exporter has already been started, the key will be added only after <a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session containing this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>Template handle previously created by <a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CKey</em>&nbsp;</td><td>Key to add (an internal copy is made of this structure and all its contents). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a201">IPDR_ERR_KEY_ALREADY_EXISTS</a>, <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a>, or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="IPDR.h::IPDR_AddKey_All"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_AddKey_All           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>CKey</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a key to a previously created template.<p>
If this function is called after the transmitter (client) has already been started, the key will be added only after <a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates()</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to the exporter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateID</em>&nbsp;</td><td>ID of the template, used in call to IPDR_CreateTemplate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CKey</em>&nbsp;</td><td>Key to add (an internal copy is made of this structure and all its contents). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a201">IPDR_ERR_KEY_ALREADY_EXISTS</a>, <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a>, or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="IPDR.h::IPDR_ApplyTemplates"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_ApplyTemplates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>SessionHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Apply a new template configuration during exporter runtime.<p>
Changes to templates, including template creation and add/remove keys, take effect only after this function runs to successful completion and also IPDR_SessionStart function is called Internally, this function will send TEMPLATE DATA message <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session to apply the templates </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. This function can not be called from within active session and will result in error. Before calling this function, IPDR_SessionStop must be called.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga10">IPDR_AddKey</a> <p>
<a class="el" href="group___i_p_d_r__templates.html#ga12">IPDR_RemoveKey</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="IPDR.h::IPDR_ApplyTemplates_All"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_ApplyTemplates_All           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ExporterHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Apply a new template configuration during exporter runtime to all existing sessions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to a Exporter previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga10">IPDR_AddKey</a> <p>
<a class="el" href="group___i_p_d_r__templates.html#ga12">IPDR_RemoveKey</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="IPDR.h::IPDR_CreateTemplate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_CreateTemplate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>SchemaName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>TypeName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumKeys</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Keys</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>TH</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new template within the exporter.<p>
This function is used to create a new template, with or without keys. Additional keys can be added to a template after its creation.<p>
A template applies to specific session. The collector may declare that it is not interested in receiving a template by disabling all the keys, in which case any ouptut of the template via <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a> will do nothing. (For efficiency, the host application might decide not to even call <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a> -- it will know that all the keys have been disabled by the <a class="el" href="group___i_p_d_r__templates.html#ga0">IPDR_TemplateChangedCallback</a> being called with all keys having <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga20">IPDR_KEY_DISABLED</a> set in the IPDR_Key.KeyAttributes field.<p>
During the exporter initialization process, all key data structures passed as arguments to this function are defined and activated. Therefore, a platform's core templates should be created in this way.<p>
Templates can also be created,KeyHelp and keys may be added to templates, dynamically (in run time). Templates and keys so created will become active only when the session is restarted. They will not persist after power-down and will not be re-created in the next initialization.<p>
When all keys in a template are accessed using offsets and all have a fixed length, it is recommended to group all mandatory keys at the beginning for efficiency purposes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to a transmitter (client) previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session to contain this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateID</em>&nbsp;</td><td>ID of template. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SchemaName</em>&nbsp;</td><td>name of the template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TypeName</em>&nbsp;</td><td>template type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumKeys</em>&nbsp;</td><td>Number of keys within the template (may be zero for an empty template). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Keys</em>&nbsp;</td><td>Array of keys associated with the template (an internal copy is made of this array and all its contents). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>(output) Handle to the newly created template. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a198">IPDR_ERR_TEMPLATE_ALREADY_EXISTS</a> or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates</a> <p>
<a class="el" href="group___i_p_d_r__templates.html#ga10">IPDR_AddKey</a> <p>
IPDR_DeleteKey </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="IPDR.h::IPDR_CreateTemplate_All"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_CreateTemplate_All           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>SchemaName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>TypeName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumKeys</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="struct_i_p_d_r___key.html">IPDR_Key</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Keys</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new template within the exporter.<p>
Previous (CRANE compatible) version of IPDR_CreateTemplate function performs corresponding operation for all sessions<p>
This function is used to create a new template, with or without keys. Additional keys can be added to a template after its creation.<p>
A template applies to specific session. The collector may declare that it is not interested in receiving a template by disabling all the keys, in which case any ouptut of the template via <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a> will do nothing. (For efficiency, the host application might decide not to even call <a class="el" href="group___i_p_d_r__data__delivery.html#ga0">IPDR_SendData()</a> -- it will know that all the keys have been disabled by the <a class="el" href="group___i_p_d_r__templates.html#ga0">IPDR_TemplateChangedCallback</a> being called with all keys having <a class="el" href="group___i_p_d_r__key__type__attributes.html#ga20">IPDR_KEY_DISABLED</a> set in the IPDR_Key.KeyAttributes field.<p>
During the exporter initialization process, all key data structures passed as arguments to this function are defined and activated. Therefore, a platform's core templates should be created in this way.<p>
Templates can also be created, and keys may be added to templates, dynamically (in run time). Templates and keys so created will become active only when the session is restarted. They will not persist after power-down and will not be re-created in the next initialization.<p>
When all keys in a template are accessed using offsets and all have a fixed length, it is recommended to group all mandatory keys at the beginning for efficiency purposes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to a transmitter (client) previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateID</em>&nbsp;</td><td>ID of template. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SchemaName</em>&nbsp;</td><td>name of the template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TypeName</em>&nbsp;</td><td>template type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumKeys</em>&nbsp;</td><td>Number of keys within the template (may be zero for an empty template). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Keys</em>&nbsp;</td><td>Array of keys associated with the template (an internal copy is made of this array and all its contents). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a198">IPDR_ERR_TEMPLATE_ALREADY_EXISTS</a> or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates</a> <p>
<a class="el" href="group___i_p_d_r__templates.html#ga10">IPDR_AddKey</a> <p>
IPDR_DeleteKey </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="IPDR.h::IPDR_DeleteTemplate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_DeleteTemplate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TH</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a previously created template. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session containing this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>Handle of template (created by <a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate()</a>) to remove. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a> or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="IPDR.h::IPDR_DeleteTemplate_All"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_DeleteTemplate_All           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a previously created template in all sessions of the exporter <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to the exporter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateID</em>&nbsp;</td><td>ID of template. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a> or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="IPDR.h::IPDR_EnableKey"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_EnableKey           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TH</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>KeyID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IPDR_BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>Enabled</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable or disable a key within a template.<p>
If this function is called after the transmitter (client) has already been started, the key will be acutally enabled or diabled only after <a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session containing this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>Template handle previously created by <a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeyID</em>&nbsp;</td><td>ID of key to remove from the template. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enabled</em>&nbsp;</td><td>- enables the key if true, disables otherwise </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a200">IPDR_ERR_KEY_NOT_FOUND</a>, <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a>, or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="IPDR.h::IPDR_EnableKey_All"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_EnableKey_All           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>KeyID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IPDR_BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>Enabled</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable or disable a key within a template.<p>
If this function is called after the transmitter (client) has already been started, the key will be acutally enabled or diabled only after <a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session containing this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>Template handle previously created by <a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeyID</em>&nbsp;</td><td>ID of key to remove from the template. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enabled</em>&nbsp;</td><td>- enables the key if true, disables otherwise </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a200">IPDR_ERR_KEY_NOT_FOUND</a>, <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a>, or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="IPDR.h::IPDR_GetTemplate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_GetTemplate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>SchemaName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>TypeName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>NumKeys</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>TH</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a template handle given a template ID. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session containing this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateID</em>&nbsp;</td><td>ID of template. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SchemaName</em>&nbsp;</td><td>(output) name of the template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TypeName</em>&nbsp;</td><td>(output) template type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumKeys</em>&nbsp;</td><td>(output) number of keys at the template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>(output) Handle to the found template. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a> or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="IPDR.h::IPDR_RemoveKey"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_RemoveKey           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___session.html">IPDR_SessionHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SessionHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_i_p_d_r__tag___template_handle.html">IPDR_TemplateHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TH</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>KeyID</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a key from a template.<p>
If this function is called after the exporter has already been started, the key will be added only after <a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SessionHandle</em>&nbsp;</td><td>Handle to session containing this template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TH</em>&nbsp;</td><td>Template handle previously created by <a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeyID</em>&nbsp;</td><td>ID of key to remove from the template. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a200">IPDR_ERR_KEY_NOT_FOUND</a>, <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a>, or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="IPDR.h::IPDR_RemoveKey_All"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_RemoveKey_All           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>TemplateID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>KeyID</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a key from a template.<p>
If this function is called after the transmitter (client) has already been started, the key will be added only after <a class="el" href="group___i_p_d_r__templates.html#ga16">IPDR_ApplyTemplates()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to the exporter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateID</em>&nbsp;</td><td>ID of the template used for <a class="el" href="group___i_p_d_r__templates.html#ga5">IPDR_CreateTemplate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeyID</em>&nbsp;</td><td>ID of key to remove from the template. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a200">IPDR_ERR_KEY_NOT_FOUND</a>, <a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a199">IPDR_ERR_TEMPLATE_NOT_FOUND</a>, or <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="IPDR.h::IPDR_SetConfigurationIDChangedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_SetConfigurationIDChangedCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___i_p_d_r__templates.html#ga2">IPDR_ConfigurationIDChangedCallback</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>Arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which will be called whenever the configuration ID changes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to an exporter previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>- extra parameter passed to the callback function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="IPDR.h::IPDR_SetFlowStartCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_SetFlowStartCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___i_p_d_r__templates.html#ga4">IPDR_FlowStartCallback</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>Arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which will be called whenever the collector sends FLOW START message. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to an exporter previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>- extra parameter passed to the callback function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="IPDR.h::IPDR_SetNewConfigurationIDCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_SetNewConfigurationIDCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___i_p_d_r__templates.html#ga1">IPDR_NewConfigurationIDCallback</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>Arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which will be called the first time we set configuration ID. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to an exporter previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>- extra parameter passed to the callback function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="IPDR.h::IPDR_SetStartNegotiationCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_SetStartNegotiationCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___i_p_d_r__templates.html#ga3">IPDR_StartNegotiationCallback</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>Arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which will be called whenever the collector sends START NEGOTIATION message. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to an exporter previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>- extra parameter passed to the callback function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="IPDR.h::IPDR_SetTemplateChangedCallback"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">IPDR_API IPDR_SetTemplateChangedCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_i_p_d_r__tag___exporter.html">IPDR_ExporterHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExporterHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___i_p_d_r__templates.html#ga0">IPDR_TemplateChangedCallback</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>Arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback which will be called whenever the templates configuration changes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExporterHandle</em>&nbsp;</td><td>Handle to an exporter previously created by <a class="el" href="group___i_p_d_r__initialization__starting__deletion.html#ga3">IPDR_InitExporter()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Arg</em>&nbsp;</td><td>- extra parameter passed to the callback function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group___i_p_d_r__general__typedefs.html#gga15a176">IPDR_OK</a> on success; <a class="el" href="group___i_p_d_r__general__typedefs.html#ga15">IPDR_STATUS_RETURN_CODE</a> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon May 30 15:54:43 2005 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
