<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>hashtable.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>hashtable.h</h1><div class="fragment"><pre>00001 <span class="comment">/* Copyright (C) 2002, The IPDR Organization, all rights reserved.</span>
00002 <span class="comment">* The use and distribution of this software is governed by the terms of</span>
00003 <span class="comment">* the license agreement which can be found in the file LICENSE.TXT at</span>
00004 <span class="comment">* the top of this source tree.</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF</span>
00007 <span class="comment">* ANY KIND, either express or implied.</span>
00008 <span class="comment">*/</span>
00009 
00010 
00011 
00012 <span class="comment">/*****************************************************</span>
00013 <span class="comment"> * File                 : hashtable                  *</span>
00014 <span class="comment"> * Description          :                            *</span>
00015 <span class="comment"> * Author               : Infosys Tech Ltd           *</span>
00016 <span class="comment"> * Modification History :                            *</span>
00017 <span class="comment"> *---------------------------------------------------*</span>
00018 <span class="comment"> * Date       Name        Change/Description         *</span>
00019 <span class="comment"> *---------------------------------------------------*</span>
00020 <span class="comment"> *                                                   *</span>
00021 <span class="comment"> *****************************************************/</span>
00022 
00023 <span class="preprocessor">#ifndef _HASHTABLE_H</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define _HASHTABLE_H</span>
00025 <span class="preprocessor"></span>
00026 <span class="comment">/* These structs should not be accessed directly from user code.</span>
00027 <span class="comment"> * All access should be via the public functions declared below. */</span>
00028 
00029 <span class="keyword">typedef</span> <span class="keyword">struct </span>KeyValuePair_struct {
00030     <span class="keyword">const</span> <span class="keywordtype">void</span> *key;
00031     <span class="keywordtype">void</span> *value;
00032     <span class="keyword">struct </span>KeyValuePair_struct *next;
00033 } KeyValuePair;
00034 
00035 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00036     <span class="keywordtype">long</span> numOfBuckets;
00037     <span class="keywordtype">long</span> numOfElements;
00038     KeyValuePair **bucketArray;
00039     <span class="keywordtype">float</span> idealRatio, lowerRehashThreshold, upperRehashThreshold;
00040     int (*keycmp)(<span class="keyword">const</span> <span class="keywordtype">void</span> *key1, <span class="keyword">const</span> <span class="keywordtype">void</span> *key2);
00041     int (*valuecmp)(<span class="keyword">const</span> <span class="keywordtype">void</span> *value1, <span class="keyword">const</span> <span class="keywordtype">void</span> *value2);
00042     <span class="keywordtype">unsigned</span> long (*hashFunction)(<span class="keyword">const</span> <span class="keywordtype">void</span> *key);
00043     void (*keyDeallocator)(<span class="keywordtype">void</span> *key);
00044     void (*valueDeallocator)(<span class="keywordtype">void</span> *value);
00045 } HashTable;
00046 
00047 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00048 <span class="comment"> *  NAME:</span>
00049 <span class="comment"> *      HashTableCreate() - creates a new HashTable</span>
00050 <span class="comment"> *  DESCRIPTION:</span>
00051 <span class="comment"> *      Creates a new HashTable.  When finished with this HashTable, it</span>
00052 <span class="comment"> *      should be explicitly destroyed by calling the HashTableDestroy()</span>
00053 <span class="comment"> *      function.</span>
00054 <span class="comment"> *  EFFICIENCY:</span>
00055 <span class="comment"> *      O(1)</span>
00056 <span class="comment"> *  ARGUMENTS:</span>
00057 <span class="comment"> *      numOfBuckets - the number of buckets to start the HashTable out with.</span>
00058 <span class="comment"> *                     Must be greater than zero, and should be prime.</span>
00059 <span class="comment"> *                     Ideally, the number of buckets should between 1/5</span>
00060 <span class="comment"> *                     and 1 times the expected number of elements in the</span>
00061 <span class="comment"> *                     HashTable.  Values much more or less than this will</span>
00062 <span class="comment"> *                     result in wasted memory or decreased performance</span>
00063 <span class="comment"> *                     respectively.  The number of buckets in a HashTable</span>
00064 <span class="comment"> *                     can be re-calculated to an appropriate number by</span>
00065 <span class="comment"> *                     calling the HashTableRehash() function once the</span>
00066 <span class="comment"> *                     HashTable has been populated.  The number of buckets</span>
00067 <span class="comment"> *                     in a HashTable may also be re-calculated</span>
00068 <span class="comment"> *                     automatically if the ratio of elements to buckets</span>
00069 <span class="comment"> *                     passes the thresholds set by HashTableSetIdealRatio().</span>
00070 <span class="comment"> *  RETURNS:</span>
00071 <span class="comment"> *      HashTable    - a new Hashtable, or NULL on error</span>
00072 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00073 
00074 HashTable *HashTableCreate(<span class="keywordtype">long</span> numOfBuckets);
00075 
00076 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00077 <span class="comment"> *  NAME:</span>
00078 <span class="comment"> *      HashTableDestroy() - destroys an existing HashTable</span>
00079 <span class="comment"> *  DESCRIPTION:</span>
00080 <span class="comment"> *      Destroys an existing HashTable.</span>
00081 <span class="comment"> *  EFFICIENCY:</span>
00082 <span class="comment"> *      O(n)</span>
00083 <span class="comment"> *  ARGUMENTS:</span>
00084 <span class="comment"> *      hashTable    - the HashTable to destroy</span>
00085 <span class="comment"> *  RETURNS:</span>
00086 <span class="comment"> *      &lt;nothing&gt;</span>
00087 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00088 
00089 <span class="keywordtype">void</span> HashTableDestroy(HashTable *hashTable);
00090 
00091 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00092 <span class="comment"> *  NAME:</span>
00093 <span class="comment"> *      HashTableContainsKey() - checks the existence of a key in a HashTable</span>
00094 <span class="comment"> *  DESCRIPTION:</span>
00095 <span class="comment"> *      Determines whether or not the specified HashTable contains the</span>
00096 <span class="comment"> *      specified key.  Uses the comparison function specified by</span>
00097 <span class="comment"> *      HashTableSetKeyComparisonFunction().</span>
00098 <span class="comment"> *  EFFICIENCY:</span>
00099 <span class="comment"> *      O(1), assuming a good hash function and element-to-bucket ratio</span>
00100 <span class="comment"> *  ARGUMENTS:</span>
00101 <span class="comment"> *      hashTable    - the HashTable to search</span>
00102 <span class="comment"> *      key          - the key to search for</span>
00103 <span class="comment"> *  RETURNS:</span>
00104 <span class="comment"> *      bool         - whether or not the specified HashTable contains the</span>
00105 <span class="comment"> *                     specified key.</span>
00106 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00107 
00108 <span class="keywordtype">int</span> HashTableContainsKey(<span class="keyword">const</span> HashTable *hashTable, <span class="keyword">const</span> <span class="keywordtype">void</span> *key);
00109 
00110 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00111 <span class="comment"> *  NAME:</span>
00112 <span class="comment"> *      HashTableContainsValue()</span>
00113 <span class="comment"> *                         - checks the existence of a value in a HashTable</span>
00114 <span class="comment"> *  DESCRIPTION:</span>
00115 <span class="comment"> *      Determines whether or not the specified HashTable contains the</span>
00116 <span class="comment"> *      specified value.  Unlike HashTableContainsKey(), this function is</span>
00117 <span class="comment"> *      not very efficient, since it has to scan linearly looking for a</span>
00118 <span class="comment"> *      match.  Uses the comparison function specified by</span>
00119 <span class="comment"> *      HashTableSetValueComparisonFunction().</span>
00120 <span class="comment"> *  EFFICIENCY:</span>
00121 <span class="comment"> *      O(n)</span>
00122 <span class="comment"> *  ARGUMENTS:</span>
00123 <span class="comment"> *      hashTable    - the HashTable to search</span>
00124 <span class="comment"> *      value        - the value to search for</span>
00125 <span class="comment"> *  RETURNS:</span>
00126 <span class="comment"> *      bool         - whether or not the specified HashTable contains the</span>
00127 <span class="comment"> *                     specified value.</span>
00128 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00129 
00130 <span class="keywordtype">int</span> HashTableContainsValue(<span class="keyword">const</span> HashTable *hashTable, <span class="keyword">const</span> <span class="keywordtype">void</span> *value);
00131 
00132 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00133 <span class="comment"> *  NAME:</span>
00134 <span class="comment"> *      HashTablePut() - adds a key/value pair to a HashTable</span>
00135 <span class="comment"> *  DESCRIPTION:</span>
00136 <span class="comment"> *      Adds the specified key/value pair to the specified HashTable.  If</span>
00137 <span class="comment"> *      the key already exists in the HashTable (determined by the comparison</span>
00138 <span class="comment"> *      function specified by HashTableSetKeyComparisonFunction()), its value</span>
00139 <span class="comment"> *      is replaced by the new value.  May trigger an auto-rehash (see</span>
00140 <span class="comment"> *      HashTableSetIdealRatio()).  It is illegal to specify NULL as the</span>
00141 <span class="comment"> *      key or value.</span>
00142 <span class="comment"> *  EFFICIENCY:</span>
00143 <span class="comment"> *      O(1), assuming a good hash function and element-to-bucket ratio</span>
00144 <span class="comment"> *  ARGUMENTS:</span>
00145 <span class="comment"> *      hashTable    - the HashTable to add to</span>
00146 <span class="comment"> *      key          - the key to add or whose value to replace</span>
00147 <span class="comment"> *      value        - the value associated with the key</span>
00148 <span class="comment"> *  RETURNS:</span>
00149 <span class="comment"> *      err          - 0 if successful, -1 if an error was encountered</span>
00150 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00151 
00152 <span class="keywordtype">int</span> HashTablePut(HashTable *hashTable, <span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">void</span> *value);
00153 
00154 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00155 <span class="comment"> *  NAME:</span>
00156 <span class="comment"> *      HashTableGet() - retrieves the value of a key in a HashTable</span>
00157 <span class="comment"> *  DESCRIPTION:</span>
00158 <span class="comment"> *      Retrieves the value of the specified key in the specified HashTable.</span>
00159 <span class="comment"> *      Uses the comparison function specified by</span>
00160 <span class="comment"> *      HashTableSetKeyComparisonFunction().</span>
00161 <span class="comment"> *  EFFICIENCY:</span>
00162 <span class="comment"> *      O(1), assuming a good hash function and element-to-bucket ratio</span>
00163 <span class="comment"> *  ARGUMENTS:</span>
00164 <span class="comment"> *      hashTable    - the HashTable to search</span>
00165 <span class="comment"> *      key          - the key whose value is desired</span>
00166 <span class="comment"> *  RETURNS:</span>
00167 <span class="comment"> *      void *       - the value of the specified key, or NULL if the key</span>
00168 <span class="comment"> *                     doesn't exist in the HashTable</span>
00169 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00170 
00171 <span class="keywordtype">void</span> *HashTableGet(<span class="keyword">const</span> HashTable *hashTable, <span class="keyword">const</span> <span class="keywordtype">void</span> *key);
00172 
00173 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00174 <span class="comment"> *  NAME:</span>
00175 <span class="comment"> *      HashTableRemove() - removes a key/value pair from a HashTable</span>
00176 <span class="comment"> *  DESCRIPTION:</span>
00177 <span class="comment"> *      Removes the key/value pair identified by the specified key from the</span>
00178 <span class="comment"> *      specified HashTable if the key exists in the HashTable.  May trigger</span>
00179 <span class="comment"> *      an auto-rehash (see HashTableSetIdealRatio()).</span>
00180 <span class="comment"> *  EFFICIENCY:</span>
00181 <span class="comment"> *      O(1), assuming a good hash function and element-to-bucket ratio</span>
00182 <span class="comment"> *  ARGUMENTS:</span>
00183 <span class="comment"> *      hashTable    - the HashTable to remove the key/value pair from</span>
00184 <span class="comment"> *      key          - the key specifying the key/value pair to be removed</span>
00185 <span class="comment"> *  RETURNS:</span>
00186 <span class="comment"> *      &lt;nothing&gt;</span>
00187 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00188 
00189 <span class="keywordtype">void</span> HashTableRemove(HashTable *hashTable, <span class="keyword">const</span> <span class="keywordtype">void</span> *key);
00190 
00191 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00192 <span class="comment"> *  NAME:</span>
00193 <span class="comment"> *      HashTableRemoveAll() - removes all key/value pairs from a HashTable</span>
00194 <span class="comment"> *  DESCRIPTION:</span>
00195 <span class="comment"> *      Removes all key/value pairs from the specified HashTable.  May trigger</span>
00196 <span class="comment"> *      an auto-rehash (see HashTableSetIdealRatio()).</span>
00197 <span class="comment"> *  EFFICIENCY:</span>
00198 <span class="comment"> *      O(n)</span>
00199 <span class="comment"> *  ARGUMENTS:</span>
00200 <span class="comment"> *      hashTable    - the HashTable to remove all key/value pairs from</span>
00201 <span class="comment"> *  RETURNS:</span>
00202 <span class="comment"> *      &lt;nothing&gt;</span>
00203 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00204 
00205 <span class="keywordtype">void</span> HashTableRemoveAll(HashTable *hashTable);
00206 
00207 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00208 <span class="comment"> *  NAME:</span>
00209 <span class="comment"> *      HashTableIsEmpty() - determines if a HashTable is empty</span>
00210 <span class="comment"> *  DESCRIPTION:</span>
00211 <span class="comment"> *      Determines whether or not the specified HashTable contains any</span>
00212 <span class="comment"> *      key/value pairs.</span>
00213 <span class="comment"> *  EFFICIENCY:</span>
00214 <span class="comment"> *      O(1)</span>
00215 <span class="comment"> *  ARGUMENTS:</span>
00216 <span class="comment"> *      hashTable    - the HashTable to check</span>
00217 <span class="comment"> *  RETURNS:</span>
00218 <span class="comment"> *      bool         - whether or not the specified HashTable contains any</span>
00219 <span class="comment"> *                     key/value pairs</span>
00220 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00221 
00222 <span class="keywordtype">int</span> HashTableIsEmpty(<span class="keyword">const</span> HashTable *hashTable);
00223 
00224 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00225 <span class="comment"> *  NAME:</span>
00226 <span class="comment"> *      HashTableSize() - returns the number of elements in a HashTable</span>
00227 <span class="comment"> *  DESCRIPTION:</span>
00228 <span class="comment"> *      Returns the number of key/value pairs that are present in the</span>
00229 <span class="comment"> *      specified HashTable.</span>
00230 <span class="comment"> *  EFFICIENCY:</span>
00231 <span class="comment"> *      O(1)</span>
00232 <span class="comment"> *  ARGUMENTS:</span>
00233 <span class="comment"> *      hashTable    - the HashTable whose size is requested</span>
00234 <span class="comment"> *  RETURNS:</span>
00235 <span class="comment"> *      long         - the number of key/value pairs that are present in</span>
00236 <span class="comment"> *                     the specified HashTable</span>
00237 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00238 
00239 <span class="keywordtype">long</span> HashTableSize(<span class="keyword">const</span> HashTable *hashTable);
00240 
00241 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00242 <span class="comment"> *  NAME:</span>
00243 <span class="comment"> *      HashTableGetNumBuckets() - returns the number of buckets in a HashTable</span>
00244 <span class="comment"> *  DESCRIPTION:</span>
00245 <span class="comment"> *      Returns the number of buckets that are in the specified HashTable.</span>
00246 <span class="comment"> *      This may change dynamically throughout the life of a HashTable if</span>
00247 <span class="comment"> *      automatic or manual rehashing is performed.</span>
00248 <span class="comment"> *  EFFICIENCY:</span>
00249 <span class="comment"> *      O(1)</span>
00250 <span class="comment"> *  ARGUMENTS:</span>
00251 <span class="comment"> *      hashTable    - the HashTable whose number of buckets is requested</span>
00252 <span class="comment"> *  RETURNS:</span>
00253 <span class="comment"> *      long         - the number of buckets that are in the specified</span>
00254 <span class="comment"> *                     HashTable</span>
00255 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00256 
00257 <span class="keywordtype">long</span> HashTableGetNumBuckets(<span class="keyword">const</span> HashTable *hashTable);
00258 
00259 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00260 <span class="comment"> *  NAME:</span>
00261 <span class="comment"> *      HashTableSetKeyComparisonFunction()</span>
00262 <span class="comment"> *              - specifies the function used to compare keys in a HashTable</span>
00263 <span class="comment"> *  DESCRIPTION:</span>
00264 <span class="comment"> *      Specifies the function used to compare keys in the specified</span>
00265 <span class="comment"> *      HashTable.  The specified function should return zero if the two</span>
00266 <span class="comment"> *      keys are considered equal, and non-zero otherwise.  The default</span>
00267 <span class="comment"> *      function is one that simply compares pointers.</span>
00268 <span class="comment"> *  ARGUMENTS:</span>
00269 <span class="comment"> *      hashTable    - the HashTable whose key comparison function is being</span>
00270 <span class="comment"> *                     specified</span>
00271 <span class="comment"> *      keycmp       - a function which returns zero if the two arguments</span>
00272 <span class="comment"> *                     passed to it are considered "equal" keys and non-zero</span>
00273 <span class="comment"> *                     otherwise</span>
00274 <span class="comment"> *  RETURNS:</span>
00275 <span class="comment"> *      &lt;nothing&gt;</span>
00276 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00277 
00278 <span class="keywordtype">void</span> HashTableSetKeyComparisonFunction(HashTable *hashTable,
00279                              <span class="keywordtype">int</span> (*keycmp)(<span class="keyword">const</span> <span class="keywordtype">void</span> *key1, <span class="keyword">const</span> <span class="keywordtype">void</span> *key2));
00280 
00281 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00282 <span class="comment"> *  NAME:</span>
00283 <span class="comment"> *      HashTableSetValueComparisonFunction()</span>
00284 <span class="comment"> *              - specifies the function used to compare values in a HashTable</span>
00285 <span class="comment"> *  DESCRIPTION:</span>
00286 <span class="comment"> *      Specifies the function used to compare values in the specified</span>
00287 <span class="comment"> *      HashTable.  The specified function should return zero if the two</span>
00288 <span class="comment"> *      values are considered equal, and non-zero otherwise.  The default</span>
00289 <span class="comment"> *      function is one that simply compares pointers.</span>
00290 <span class="comment"> *  ARGUMENTS:</span>
00291 <span class="comment"> *      hashTable    - the HashTable whose value comparison function is being</span>
00292 <span class="comment"> *                     specified</span>
00293 <span class="comment"> *      valuecmp     - a function which returns zero if the two arguments</span>
00294 <span class="comment"> *                     passed to it are considered "equal" values and non-zero</span>
00295 <span class="comment"> *                     otherwise</span>
00296 <span class="comment"> *  RETURNS:</span>
00297 <span class="comment"> *      &lt;nothing&gt;</span>
00298 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00299 
00300 <span class="keywordtype">void</span> HashTableSetValueComparisonFunction(HashTable *hashTable,
00301                        <span class="keywordtype">int</span> (*valuecmp)(<span class="keyword">const</span> <span class="keywordtype">void</span> *value1, <span class="keyword">const</span> <span class="keywordtype">void</span> *value2));
00302 
00303 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00304 <span class="comment"> *  NAME:</span>
00305 <span class="comment"> *      HashTableSetHashFunction()</span>
00306 <span class="comment"> *              - specifies the hash function used by a HashTable</span>
00307 <span class="comment"> *  DESCRIPTION:</span>
00308 <span class="comment"> *      Specifies the function used to determine the hash value for a key</span>
00309 <span class="comment"> *      in the specified HashTable (before modulation).  An ideal hash</span>
00310 <span class="comment"> *      function is one which is easy to compute and approximates a</span>
00311 <span class="comment"> *      "random" function.  The default function is one that works</span>
00312 <span class="comment"> *      relatively well for pointers.  If the HashTable keys are to be</span>
00313 <span class="comment"> *      strings (which is probably the case), then this default function</span>
00314 <span class="comment"> *      will not suffice, in which case consider using the provided</span>
00315 <span class="comment"> *      HashTableStringHashFunction() function.</span>
00316 <span class="comment"> *  ARGUMENTS:</span>
00317 <span class="comment"> *      hashTable    - the HashTable whose hash function is being specified</span>
00318 <span class="comment"> *      hashFunction - a function which returns an appropriate hash code</span>
00319 <span class="comment"> *                     for a given key</span>
00320 <span class="comment"> *  RETURNS:</span>
00321 <span class="comment"> *      &lt;nothing&gt;</span>
00322 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00323 
00324 <span class="keywordtype">void</span> HashTableSetHashFunction(HashTable *hashTable,
00325                               <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> (*hashFunction)(<span class="keyword">const</span> <span class="keywordtype">void</span> *key));
00326 
00327 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00328 <span class="comment"> *  NAME:</span>
00329 <span class="comment"> *      HashTableRehash() - reorganizes a HashTable to be more efficient</span>
00330 <span class="comment"> *  DESCRIPTION:</span>
00331 <span class="comment"> *      Reorganizes a HashTable to be more efficient.  If a number of</span>
00332 <span class="comment"> *      buckets is specified, the HashTable is rehashed to that number of</span>
00333 <span class="comment"> *      buckets.  If 0 is specified, the HashTable is rehashed to a number</span>
00334 <span class="comment"> *      of buckets which is automatically calculated to be a prime number</span>
00335 <span class="comment"> *      that achieves (as closely as possible) the ideal element-to-bucket </span>
00336 <span class="comment"> *      ratio specified by the HashTableSetIdealRatio() function.</span>
00337 <span class="comment"> *  EFFICIENCY:</span>
00338 <span class="comment"> *      O(n)</span>
00339 <span class="comment"> *  ARGUMENTS:</span>
00340 <span class="comment"> *      hashTable    - the HashTable to be reorganized</span>
00341 <span class="comment"> *      numOfBuckets - the number of buckets to rehash the HashTable to.</span>
00342 <span class="comment"> *                     Should be prime.  Ideally, the number of buckets</span>
00343 <span class="comment"> *                     should be between 1/5 and 1 times the expected</span>
00344 <span class="comment"> *                     number of elements in the HashTable.  Values much</span>
00345 <span class="comment"> *                     more or less than this will result in wasted memory</span>
00346 <span class="comment"> *                     or decreased performance respectively.  If 0 is</span>
00347 <span class="comment"> *                     specified, an appropriate number of buckets is</span>
00348 <span class="comment"> *                     automatically calculated.</span>
00349 <span class="comment"> *  RETURNS:</span>
00350 <span class="comment"> *      &lt;nothing&gt;</span>
00351 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00352 
00353 <span class="keywordtype">void</span> HashTableRehash(HashTable *hashTable, <span class="keywordtype">long</span> numOfBuckets);
00354 
00355 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00356 <span class="comment"> *  NAME:</span>
00357 <span class="comment"> *      HashTableSetIdealRatio()</span>
00358 <span class="comment"> *              - sets the ideal element-to-bucket ratio of a HashTable</span>
00359 <span class="comment"> *  DESCRIPTION:</span>
00360 <span class="comment"> *      Sets the ideal element-to-bucket ratio, as well as the lower and</span>
00361 <span class="comment"> *      upper auto-rehash thresholds, of the specified HashTable.  Note</span>
00362 <span class="comment"> *      that this function doesn't actually perform a rehash.</span>
00363 <span class="comment"> *</span>
00364 <span class="comment"> *      The default values for these properties are 3.0, 0.0 and 15.0</span>
00365 <span class="comment"> *      respectively.  This is likely fine for most situations, so there</span>
00366 <span class="comment"> *      is probably no need to call this function.</span>
00367 <span class="comment"> *  ARGUMENTS:</span>
00368 <span class="comment"> *      hashTable    - a HashTable</span>
00369 <span class="comment"> *      idealRatio   - the ideal element-to-bucket ratio.  When a rehash</span>
00370 <span class="comment"> *                     occurs (either manually via a call to the</span>
00371 <span class="comment"> *                     HashTableRehash() function or automatically due the</span>
00372 <span class="comment"> *                     the triggering of one of the thresholds below), the</span>
00373 <span class="comment"> *                     number of buckets in the HashTable will be</span>
00374 <span class="comment"> *                     recalculated to be a prime number that achieves (as</span>
00375 <span class="comment"> *                     closely as possible) this ideal ratio.  Must be a</span>
00376 <span class="comment"> *                     positive number.</span>
00377 <span class="comment"> *      lowerRehashThreshold</span>
00378 <span class="comment"> *                   - the element-to-bucket ratio that is considered</span>
00379 <span class="comment"> *                     unacceptably low (i.e., too few elements per bucket).</span>
00380 <span class="comment"> *                     If the actual ratio falls below this number, a</span>
00381 <span class="comment"> *                     rehash will automatically be performed.  Must be</span>
00382 <span class="comment"> *                     lower than the value of idealRatio.  If no ratio</span>
00383 <span class="comment"> *                     is considered unacceptably low, a value of 0.0 can</span>
00384 <span class="comment"> *                     be specified.</span>
00385 <span class="comment"> *      upperRehashThreshold</span>
00386 <span class="comment"> *                   - the element-to-bucket ratio that is considered</span>
00387 <span class="comment"> *                     unacceptably high (i.e., too many elements per bucket).</span>
00388 <span class="comment"> *                     If the actual ratio rises above this number, a</span>
00389 <span class="comment"> *                     rehash will automatically be performed.  Must be</span>
00390 <span class="comment"> *                     higher than idealRatio.  However, if no ratio</span>
00391 <span class="comment"> *                     is considered unacceptably high, a value of 0.0 can</span>
00392 <span class="comment"> *                     be specified.</span>
00393 <span class="comment"> *  RETURNS:</span>
00394 <span class="comment"> *      &lt;nothing&gt;</span>
00395 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00396 
00397 <span class="keywordtype">void</span> HashTableSetIdealRatio(HashTable *hashTable, <span class="keywordtype">float</span> idealRatio,
00398                             <span class="keywordtype">float</span> lowerRehashThreshold,
00399                             <span class="keywordtype">float</span> upperRehashThreshold);
00400 
00401 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00402 <span class="comment"> *  NAME:</span>
00403 <span class="comment"> *      HashTableSetDeallocationFunctions()</span>
00404 <span class="comment"> *              - sets the key and value deallocation functions of a HashTable</span>
00405 <span class="comment"> *  DESCRIPTION:</span>
00406 <span class="comment"> *      Sets the key and value deallocation functions of the specified</span>
00407 <span class="comment"> *      HashTable.  This determines what happens to a key or a value when it</span>
00408 <span class="comment"> *      is removed from the HashTable.  If the deallocation function is NULL</span>
00409 <span class="comment"> *      (the default if this function is never called), its reference is</span>
00410 <span class="comment"> *      simply dropped and it is up to the calling program to perform the</span>
00411 <span class="comment"> *      proper memory management.  If the deallocation function is non-NULL,</span>
00412 <span class="comment"> *      it is called to free the memory used by the object.  E.g., for simple</span>
00413 <span class="comment"> *      objects, an appropriate deallocation function may be free().</span>
00414 <span class="comment"> *</span>
00415 <span class="comment"> *      This affects the behaviour of the HashTableDestroy(), HashTablePut(),</span>
00416 <span class="comment"> *      HashTableRemove() and HashTableRemoveAll() functions.</span>
00417 <span class="comment"> *  ARGUMENTS:</span>
00418 <span class="comment"> *      hashTable    - a HashTable</span>
00419 <span class="comment"> *      keyDeallocator</span>
00420 <span class="comment"> *                   - if non-NULL, the function to be called when a key is</span>
00421 <span class="comment"> *                     removed from the HashTable.</span>
00422 <span class="comment"> *      valueDeallocator</span>
00423 <span class="comment"> *                   - if non-NULL, the function to be called when a value is</span>
00424 <span class="comment"> *                     removed from the HashTable.</span>
00425 <span class="comment"> *  RETURNS:</span>
00426 <span class="comment"> *      &lt;nothing&gt;</span>
00427 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00428 
00429 <span class="keywordtype">void</span> HashTableSetDeallocationFunctions(HashTable *hashTable,
00430                                        <span class="keywordtype">void</span> (*keyDeallocator)(<span class="keywordtype">void</span> *key),
00431                                        <span class="keywordtype">void</span> (*valueDeallocator)(<span class="keywordtype">void</span> *value));
00432 
00433 <span class="comment">/*--------------------------------------------------------------------------*\</span>
00434 <span class="comment"> *  NAME:</span>
00435 <span class="comment"> *      HashTableStringHashFunction() - a good hash function for strings</span>
00436 <span class="comment"> *  DESCRIPTION:</span>
00437 <span class="comment"> *      A hash function that is appropriate for hashing strings.  Note that</span>
00438 <span class="comment"> *      this is not the default hash function.  To make it the default hash</span>
00439 <span class="comment"> *      function, call HashTableSetHashFunction(HashTableStringHashFunction).</span>
00440 <span class="comment"> *  ARGUMENTS:</span>
00441 <span class="comment"> *      key    - the key to be hashed</span>
00442 <span class="comment"> *  RETURNS:</span>
00443 <span class="comment"> *      long   - the unmodulated hash value of the key</span>
00444 <span class="comment">\*--------------------------------------------------------------------------*/</span>
00445 
00446 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> HashTableStringHashFunction(<span class="keyword">const</span> <span class="keywordtype">void</span> *key);
00447 
00469 <span class="keywordtype">int</span> HashTablePutstr(
00470                                         HashTable *hashTable, 
00471                                         <span class="keyword">const</span> <span class="keywordtype">void</span> *key, 
00472                                         <span class="keywordtype">void</span> *value
00473                                         ); 
00474 
00475 <span class="preprocessor">#endif </span><span class="comment">/* _HASHTABLE_H */</span>
</pre></div><hr><address style="align: right;"><small>Generated on Fri Nov 5 19:10:08 2004 for IPDR BASE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
